/**
 * VRChat API Documentation
 *
 * The version of the OpenAPI document: 1.10.1
 * Contact: me@ariesclark.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Configuration } from './configuration';
import { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { RequestArgs, BaseAPI } from './base';
/**
 *
 * @export
 * @interface APIConfig
 */
export interface APIConfig {
    /**
     * Unknown, probably voice optimization testing
     * @type {boolean}
     * @memberof APIConfig
     */
    'VoiceEnableDegradation': boolean;
    /**
     * Unknown, probably voice optimization testing
     * @type {boolean}
     * @memberof APIConfig
     */
    'VoiceEnableReceiverLimiting': boolean;
    /**
     * VRChat\'s office address
     * @type {string}
     * @memberof APIConfig
     */
    'address': string;
    /**
     * Public Announcements
     * @type {Set<APIConfigAnnouncement>}
     * @memberof APIConfig
     */
    'announcements': Set<APIConfigAnnouncement>;
    /**
     * apiKey to be used for all other requests
     * @type {string}
     * @memberof APIConfig
     */
    'apiKey': string;
    /**
     * Game name
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'appName': string;
    /**
     * Build tag of the API server
     * @type {string}
     * @memberof APIConfig
     */
    'buildVersionTag': string;
    /**
     * apiKey to be used for all other requests
     * @type {string}
     * @memberof APIConfig
     */
    'clientApiKey': string;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientBPSCeiling': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientDisconnectTimeout': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientReservedPlayerBPS': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'clientSentCountAllowance': number;
    /**
     * VRChat\'s contact email
     * @type {string}
     * @memberof APIConfig
     */
    'contactEmail': string;
    /**
     * VRChat\'s copyright-issues-related email
     * @type {string}
     * @memberof APIConfig
     */
    'copyrightEmail': string;
    /**
     * Current version number of the Terms of Service
     * @type {number}
     * @memberof APIConfig
     */
    'currentTOSVersion': number;
    /**
     *
     * @type {string}
     * @memberof APIConfig
     */
    'defaultAvatar': string;
    /**
     *
     * @type {DeploymentGroup}
     * @memberof APIConfig
     */
    'deploymentGroup': DeploymentGroup;
    /**
     * Version number for game development build
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'devAppVersionStandalone': string;
    /**
     * Developer Download link
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'devDownloadLinkWindows': string;
    /**
     * Link to download the development SDK, use downloadUrls instead
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'devSdkUrl': string;
    /**
     * Version of the development SDK
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'devSdkVersion': string;
    /**
     * Version number for server development build
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'devServerVersionStandalone': string;
    /**
     * Unknown, \"dis\" maybe for disconnect?
     * @type {string}
     * @memberof APIConfig
     */
    'dis-countdown': string;
    /**
     * Toggles if copying avatars should be disabled
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableAvatarCopying': boolean;
    /**
     * Toggles if avatar gating should be disabled. Avatar gating restricts uploading of avatars to people with the `system_avatar_access` Tag or `admin_avatar_access` Tag
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableAvatarGating': boolean;
    /**
     * Toggles if the Community Labs should be disabled
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableCommunityLabs': boolean;
    /**
     * Toggles if promotion out of Community Labs should be disabled
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableCommunityLabsPromotion': boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableEmail': boolean;
    /**
     * Toggles if Analytics should be disabled.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableEventStream': boolean;
    /**
     * Toggles if feedback gating should be disabled. Feedback gating restricts submission of feedback (reporting a World or User) to people with the `system_feedback_access` Tag.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableFeedbackGating': boolean;
    /**
     * Unknown, probably toggles compilation of frontend web builds? So internal flag?
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableFrontendBuilds': boolean;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableHello': boolean;
    /**
     * Toggles if signing up for Subscriptions in Oculus is disabled or not.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableOculusSubs': boolean;
    /**
     * Toggles if new user account registration should be disabled.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableRegistration': boolean;
    /**
     * Toggles if Steam Networking should be disabled. VRChat these days uses Photon Unity Networking (PUN) instead.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableSteamNetworking': boolean;
    /**
     * Toggles if 2FA should be disabled.
     * @type {boolean}
     * @memberof APIConfig
     * @deprecated
     */
    'disableTwoFactorAuth': boolean;
    /**
     * Toggles if Udon should be universally disabled in-game.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableUdon': boolean;
    /**
     * Toggles if account upgrading \"linking with Steam/Oculus\" should be disabled.
     * @type {boolean}
     * @memberof APIConfig
     */
    'disableUpgradeAccount': boolean;
    /**
     * Download link for game on the Oculus Rift website.
     * @type {string}
     * @memberof APIConfig
     */
    'downloadLinkWindows': string;
    /**
     *
     * @type {APIConfigDownloadURLList}
     * @memberof APIConfig
     */
    'downloadUrls': APIConfigDownloadURLList;
    /**
     * Array of DynamicWorldRow objects, used by the game to display the list of world rows
     * @type {Set<DynamicContentRow>}
     * @memberof APIConfig
     */
    'dynamicWorldRows': Set<DynamicContentRow>;
    /**
     *
     * @type {APIConfigEvents}
     * @memberof APIConfig
     */
    'events': APIConfigEvents;
    /**
     * Unknown
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'gearDemoRoomId': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof APIConfig
     */
    'homeWorldId': string;
    /**
     * Redirect target if you try to open the base API domain in your browser
     * @type {string}
     * @memberof APIConfig
     */
    'homepageRedirectTarget': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof APIConfig
     */
    'hubWorldId': string;
    /**
     * VRChat\'s job application email
     * @type {string}
     * @memberof APIConfig
     */
    'jobsEmail': string;
    /**
     * MOTD
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'messageOfTheDay': string;
    /**
     * VRChat\'s moderation related email
     * @type {string}
     * @memberof APIConfig
     */
    'moderationEmail': string;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'moderationQueryPeriod': number;
    /**
     * Used in-game to notify a user they aren\'t allowed to select avatars in private worlds
     * @type {string}
     * @memberof APIConfig
     */
    'notAllowedToSelectAvatarInPrivateWorldMessage': string;
    /**
     * Extra [plugin](https://doc.photonengine.com/en-us/server/current/plugins/manual) to run in each instance
     * @type {string}
     * @memberof APIConfig
     */
    'plugin': string;
    /**
     * Version number for game release build
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'releaseAppVersionStandalone': string;
    /**
     * Link to download the release SDK
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'releaseSdkUrl': string;
    /**
     * Version of the release SDK
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'releaseSdkVersion': string;
    /**
     * Version number for server release build
     * @type {string}
     * @memberof APIConfig
     * @deprecated
     */
    'releaseServerVersionStandalone': string;
    /**
     * Link to the developer FAQ
     * @type {string}
     * @memberof APIConfig
     */
    'sdkDeveloperFaqUrl': string;
    /**
     * Link to the official VRChat Discord
     * @type {string}
     * @memberof APIConfig
     */
    'sdkDiscordUrl': string;
    /**
     * Used in the SDK to notify a user they aren\'t allowed to upload avatars/worlds yet
     * @type {string}
     * @memberof APIConfig
     */
    'sdkNotAllowedToPublishMessage': string;
    /**
     * Unity version supported by the SDK
     * @type {string}
     * @memberof APIConfig
     */
    'sdkUnityVersion': string;
    /**
     * Server name of the API server currently responding
     * @type {string}
     * @memberof APIConfig
     */
    'serverName': string;
    /**
     * VRChat\'s support email
     * @type {string}
     * @memberof APIConfig
     */
    'supportEmail': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof APIConfig
     */
    'timeOutWorldId': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof APIConfig
     */
    'tutorialWorldId': string;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'updateRateMsMaximum': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'updateRateMsMinimum': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'updateRateMsNormal': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'updateRateMsUdonManual': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'uploadAnalysisPercent': number;
    /**
     * List of allowed URLs that bypass the \"Allow untrusted URL\'s\" setting in-game
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'urlList': Array<string>;
    /**
     * Unknown
     * @type {boolean}
     * @memberof APIConfig
     */
    'useReliableUdpForVoice': boolean;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'userUpdatePeriod': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'userVerificationDelay': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'userVerificationRetry': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'userVerificationTimeout': number;
    /**
     * Download link for game on the Steam website.
     * @type {string}
     * @memberof APIConfig
     */
    'viveWindowsUrl': string;
    /**
     * List of allowed URLs that are allowed to host avatar assets
     * @type {Array<string>}
     * @memberof APIConfig
     */
    'whiteListedAssetUrls': Array<string>;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfig
     */
    'worldUpdatePeriod': number;
    /**
     * Currently used youtube-dl.exe hash in SHA-256-delimited format
     * @type {string}
     * @memberof APIConfig
     */
    'player-url-resolver-hash': string;
    /**
     * Currently used youtube-dl.exe version
     * @type {string}
     * @memberof APIConfig
     */
    'player-url-resolver-version': string;
}
/**
 * Public Announcement
 * @export
 * @interface APIConfigAnnouncement
 */
export interface APIConfigAnnouncement {
    /**
     * Announcement name
     * @type {string}
     * @memberof APIConfigAnnouncement
     */
    'name': string;
    /**
     * Announcement text
     * @type {string}
     * @memberof APIConfigAnnouncement
     */
    'text': string;
}
/**
 * Download links for various development assets.
 * @export
 * @interface APIConfigDownloadURLList
 */
export interface APIConfigDownloadURLList {
    /**
     * Download link for legacy SDK2
     * @type {string}
     * @memberof APIConfigDownloadURLList
     * @deprecated
     */
    'sdk2': string;
    /**
     * Download link for SDK3 for Avatars
     * @type {string}
     * @memberof APIConfigDownloadURLList
     */
    'sdk3-avatars': string;
    /**
     * Download link for SDK3 for Worlds
     * @type {string}
     * @memberof APIConfigDownloadURLList
     */
    'sdk3-worlds': string;
}
/**
 *
 * @export
 * @interface APIConfigEvents
 */
export interface APIConfigEvents {
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'distanceClose': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'distanceFactor': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'distanceFar': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'groupDistance': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'maximumBunchSize': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'notVisibleFactor': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'playerOrderBucketSize': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'playerOrderFactor': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'slowUpdateFactorThreshold': number;
    /**
     * Unknown
     * @type {number}
     * @memberof APIConfigEvents
     */
    'viewSegmentLength': number;
}
/**
 *
 * @export
 * @interface APIHealth
 */
export interface APIHealth {
    /**
     *
     * @type {boolean}
     * @memberof APIHealth
     */
    'ok': boolean;
    /**
     *
     * @type {string}
     * @memberof APIHealth
     */
    'serverName': string;
    /**
     *
     * @type {string}
     * @memberof APIHealth
     */
    'buildVersionTag': string;
}
/**
 *
 * @export
 * @interface AccountDeletionLog
 */
export interface AccountDeletionLog {
    /**
     * Typically \"Deletion requested\" or \"Deletion canceled\". Other messages like \"Deletion completed\" may exist, but are these are not possible to see as a regular user.
     * @type {string}
     * @memberof AccountDeletionLog
     */
    'message'?: string;
    /**
     * When the deletion is scheduled to happen, standard is 14 days after the request.
     * @type {string}
     * @memberof AccountDeletionLog
     */
    'deletionScheduled'?: string | null;
    /**
     * Date and time of the deletion request.
     * @type {string}
     * @memberof AccountDeletionLog
     */
    'dateTime'?: string;
}
/**
 *
 * @export
 * @interface AddFavoriteRequest
 */
export interface AddFavoriteRequest {
    /**
     *
     * @type {FavoriteType}
     * @memberof AddFavoriteRequest
     */
    'type': FavoriteType;
    /**
     * Must be either AvatarID, WorldID or UserID.
     * @type {string}
     * @memberof AddFavoriteRequest
     */
    'favoriteId': string;
    /**
     * Tags indicate which group this favorite belongs to. Adding multiple groups makes it show up in all. Removing it from one in that case removes it from all.
     * @type {Array<string>}
     * @memberof AddFavoriteRequest
     */
    'tags': Array<string>;
}
/**
 *
 * @export
 * @interface AddGroupGalleryImageRequest
 */
export interface AddGroupGalleryImageRequest {
    /**
     *
     * @type {string}
     * @memberof AddGroupGalleryImageRequest
     */
    'fileId': string;
}
/**
 *
 * @export
 * @interface Avatar
 */
export interface Avatar {
    /**
     * Not present from general serach `/avatars`, only on specific requests `/avatars/{avatarId}`.
     * @type {string}
     * @memberof Avatar
     */
    'assetUrl'?: string;
    /**
     * Not present from general serach `/avatars`, only on specific requests `/avatars/{avatarId}`. **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
     * @type {object}
     * @memberof Avatar
     */
    'assetUrlObject'?: object;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Avatar
     */
    'authorId': string;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'authorName': string;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'description': string;
    /**
     *
     * @type {boolean}
     * @memberof Avatar
     */
    'featured': boolean;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'imageUrl': string;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'name': string;
    /**
     *
     * @type {ReleaseStatus}
     * @memberof Avatar
     */
    'releaseStatus': ReleaseStatus;
    /**
     *
     * @type {Array<string>}
     * @memberof Avatar
     */
    'tags': Array<string>;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'thumbnailImageUrl': string;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'unityPackageUrl': string;
    /**
     *
     * @type {AvatarUnityPackageUrlObject}
     * @memberof Avatar
     * @deprecated
     */
    'unityPackageUrlObject': AvatarUnityPackageUrlObject;
    /**
     *
     * @type {Set<UnityPackage>}
     * @memberof Avatar
     */
    'unityPackages': Set<UnityPackage>;
    /**
     *
     * @type {string}
     * @memberof Avatar
     */
    'updated_at': string;
    /**
     *
     * @type {number}
     * @memberof Avatar
     */
    'version': number;
}
/**
 * **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
 * @export
 * @interface AvatarUnityPackageUrlObject
 */
export interface AvatarUnityPackageUrlObject {
    /**
     *
     * @type {string}
     * @memberof AvatarUnityPackageUrlObject
     */
    'unityPackageUrl'?: string;
}
/**
 *
 * @export
 * @interface BanGroupMemberRequest
 */
export interface BanGroupMemberRequest {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof BanGroupMemberRequest
     */
    'userId': string;
}
/**
 *
 * @export
 * @interface CreateAvatarRequest
 */
export interface CreateAvatarRequest {
    /**
     *
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'assetUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'description'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateAvatarRequest
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'imageUrl': string;
    /**
     *
     * @type {ReleaseStatus}
     * @memberof CreateAvatarRequest
     */
    'releaseStatus'?: ReleaseStatus;
    /**
     *
     * @type {number}
     * @memberof CreateAvatarRequest
     */
    'version'?: number;
    /**
     *
     * @type {string}
     * @memberof CreateAvatarRequest
     */
    'unityPackageUrl'?: string;
}
/**
 *
 * @export
 * @interface CreateFileRequest
 */
export interface CreateFileRequest {
    /**
     *
     * @type {string}
     * @memberof CreateFileRequest
     */
    'name': string;
    /**
     *
     * @type {MIMEType}
     * @memberof CreateFileRequest
     */
    'mimeType': MIMEType;
    /**
     *
     * @type {string}
     * @memberof CreateFileRequest
     */
    'extension': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateFileRequest
     */
    'tags'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateFileVersionRequest
 */
export interface CreateFileVersionRequest {
    /**
     *
     * @type {string}
     * @memberof CreateFileVersionRequest
     */
    'signatureMd5': string;
    /**
     *
     * @type {number}
     * @memberof CreateFileVersionRequest
     */
    'signatureSizeInBytes': number;
    /**
     *
     * @type {string}
     * @memberof CreateFileVersionRequest
     */
    'fileMd5'?: string;
    /**
     *
     * @type {number}
     * @memberof CreateFileVersionRequest
     */
    'fileSizeInBytes'?: number;
}
/**
 *
 * @export
 * @interface CreateGroupAnnouncementRequest
 */
export interface CreateGroupAnnouncementRequest {
    /**
     * Announcement title
     * @type {string}
     * @memberof CreateGroupAnnouncementRequest
     */
    'title': string;
    /**
     * Announcement text
     * @type {string}
     * @memberof CreateGroupAnnouncementRequest
     */
    'text'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateGroupAnnouncementRequest
     */
    'imageId'?: string;
    /**
     * Send notification to group members.
     * @type {boolean}
     * @memberof CreateGroupAnnouncementRequest
     */
    'sendNotification'?: boolean;
}
/**
 *
 * @export
 * @interface CreateGroupGalleryRequest
 */
export interface CreateGroupGalleryRequest {
    /**
     * Name of the gallery.
     * @type {string}
     * @memberof CreateGroupGalleryRequest
     */
    'name': string;
    /**
     * Description of the gallery.
     * @type {string}
     * @memberof CreateGroupGalleryRequest
     */
    'description'?: string;
    /**
     * Whether the gallery is members only.
     * @type {boolean}
     * @memberof CreateGroupGalleryRequest
     */
    'membersOnly'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateGroupGalleryRequest
     */
    'roleIdsToView'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateGroupGalleryRequest
     */
    'roleIdsToSubmit'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateGroupGalleryRequest
     */
    'roleIdsToAutoApprove'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateGroupGalleryRequest
     */
    'roleIdsToManage'?: Array<string> | null;
}
/**
 *
 * @export
 * @interface CreateGroupInviteRequest
 */
export interface CreateGroupInviteRequest {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof CreateGroupInviteRequest
     */
    'userId': string;
    /**
     *
     * @type {boolean}
     * @memberof CreateGroupInviteRequest
     */
    'confirmOverrideBlock'?: boolean;
}
/**
 *
 * @export
 * @interface CreateGroupRequest
 */
export interface CreateGroupRequest {
    /**
     *
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'shortCode': string;
    /**
     *
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'description'?: string;
    /**
     *
     * @type {GroupJoinState}
     * @memberof CreateGroupRequest
     */
    'joinState'?: GroupJoinState;
    /**
     *
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'iconId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CreateGroupRequest
     */
    'bannerId'?: string | null;
    /**
     *
     * @type {GroupPrivacy}
     * @memberof CreateGroupRequest
     */
    'privacy'?: GroupPrivacy;
    /**
     *
     * @type {GroupRoleTemplate}
     * @memberof CreateGroupRequest
     */
    'roleTemplate': GroupRoleTemplate;
}
/**
 *
 * @export
 * @interface CreateGroupRoleRequest
 */
export interface CreateGroupRoleRequest {
    /**
     *
     * @type {string}
     * @memberof CreateGroupRoleRequest
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateGroupRoleRequest
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateGroupRoleRequest
     */
    'description'?: string;
    /**
     *
     * @type {boolean}
     * @memberof CreateGroupRoleRequest
     */
    'isSelfAssignable'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateGroupRoleRequest
     */
    'permissions'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateWorldRequest
 */
export interface CreateWorldRequest {
    /**
     *
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'assetUrl': string;
    /**
     *
     * @type {number}
     * @memberof CreateWorldRequest
     */
    'assetVersion'?: number;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'authorId'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'authorName'?: string;
    /**
     *
     * @type {number}
     * @memberof CreateWorldRequest
     */
    'capacity'?: number;
    /**
     *
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'description'?: string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'imageUrl': string;
    /**
     *
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'name': string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'platform'?: string;
    /**
     *
     * @type {ReleaseStatus}
     * @memberof CreateWorldRequest
     */
    'releaseStatus'?: ReleaseStatus;
    /**
     *
     * @type {Array<string>}
     * @memberof CreateWorldRequest
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'unityPackageUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof CreateWorldRequest
     */
    'unityVersion'?: string;
}
/**
 *
 * @export
 * @interface CurrentUser
 */
export interface CurrentUser {
    /**
     *
     * @type {number}
     * @memberof CurrentUser
     */
    'acceptedTOSVersion': number;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'accountDeletionDate'?: string | null;
    /**
     *
     * @type {Array<AccountDeletionLog>}
     * @memberof CurrentUser
     */
    'accountDeletionLog'?: Array<AccountDeletionLog>;
    /**
     *
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'activeFriends'?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'allowAvatarCopying': boolean;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'bio': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'bioLinks': Array<string>;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'currentAvatar': string;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'currentAvatarAssetUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof CurrentUser
     */
    'currentAvatarImageUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof CurrentUser
     */
    'currentAvatarThumbnailImageUrl': string;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'date_joined': string;
    /**
     *
     * @type {DeveloperType}
     * @memberof CurrentUser
     */
    'developerType': DeveloperType;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'displayName': string;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'emailVerified': boolean;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'fallbackAvatar'?: string;
    /**
     * Always empty array.
     * @type {Array<string>}
     * @memberof CurrentUser
     * @deprecated
     */
    'friendGroupNames': Array<string>;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'friendKey': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'friends': Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hasBirthday': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hasEmail': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hasLoggedInFromClient': boolean;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'hasPendingEmail': boolean;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof CurrentUser
     */
    'homeLocation': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof CurrentUser
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'isFriend': boolean;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'last_login': string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof CurrentUser
     */
    'last_platform': string;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'obfuscatedEmail': string;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'obfuscatedPendingEmail': string;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'oculusId': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'offlineFriends'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'onlineFriends'?: Array<string>;
    /**
     *
     * @type {Array<PastDisplayName>}
     * @memberof CurrentUser
     */
    'pastDisplayNames': Array<PastDisplayName>;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'profilePicOverride': string;
    /**
     *
     * @type {UserState}
     * @memberof CurrentUser
     */
    'state': UserState;
    /**
     *
     * @type {UserStatus}
     * @memberof CurrentUser
     */
    'status': UserStatus;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'statusDescription': string;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'statusFirstTime': boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'statusHistory': Array<string>;
    /**
     *
     * @type {object}
     * @memberof CurrentUser
     */
    'steamDetails': object;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'steamId': string;
    /**
     *
     * @type {Array<string>}
     * @memberof CurrentUser
     */
    'tags': Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'twoFactorAuthEnabled': boolean;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'twoFactorAuthEnabledDate'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof CurrentUser
     */
    'unsubscribe': boolean;
    /**
     *
     * @type {string}
     * @memberof CurrentUser
     */
    'userIcon': string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof CurrentUser
     * @deprecated
     */
    'username'?: string;
}
/**
 * Used to identify which API deployment cluster is currently responding.  `blue` and `green` are used by Production. `grape`and `cherry` are used during Development.  [Blue Green Deployment by Martin Fowler](https://martinfowler.com/bliki/BlueGreenDeployment.html)
 * @export
 * @enum {string}
 */
export declare const DeploymentGroup: {
    readonly Blue: "blue";
    readonly Green: "green";
    readonly Grape: "grape";
    readonly Cherry: "cherry";
};
export type DeploymentGroup = typeof DeploymentGroup[keyof typeof DeploymentGroup];
/**
 * \"none\" User is a normal user \"trusted\" Unknown \"internal\" Is a VRChat Developer \"moderator\" Is a VRChat Moderator  Staff can hide their developerType at will.
 * @export
 * @enum {string}
 */
export declare const DeveloperType: {
    readonly None: "none";
    readonly Trusted: "trusted";
    readonly Internal: "internal";
    readonly Moderator: "moderator";
};
export type DeveloperType = typeof DeveloperType[keyof typeof DeveloperType];
/**
 *
 * @export
 * @interface DynamicContentRow
 */
export interface DynamicContentRow {
    /**
     *
     * @type {number}
     * @memberof DynamicContentRow
     */
    'index'?: number;
    /**
     *
     * @type {string}
     * @memberof DynamicContentRow
     */
    'name': string;
    /**
     * Usually \"ThisPlatformSupported\", but can also be other values such as \"all\" or platform specific identifiers.
     * @type {string}
     * @memberof DynamicContentRow
     */
    'platform': string;
    /**
     *
     * @type {string}
     * @memberof DynamicContentRow
     */
    'sortHeading': string;
    /**
     *
     * @type {string}
     * @memberof DynamicContentRow
     */
    'sortOrder': string;
    /**
     *
     * @type {string}
     * @memberof DynamicContentRow
     */
    'sortOwnership': string;
    /**
     * Tag to filter content for this row.
     * @type {string}
     * @memberof DynamicContentRow
     */
    'tag'?: string;
    /**
     * Type is not present if it is a world.
     * @type {string}
     * @memberof DynamicContentRow
     */
    'type'?: string;
}
/**
 *
 * @export
 * @interface Favorite
 */
export interface Favorite {
    /**
     * MUST be either AvatarID, UserID or WorldID.
     * @type {string}
     * @memberof Favorite
     */
    'favoriteId': string;
    /**
     *
     * @type {string}
     * @memberof Favorite
     */
    'id': string;
    /**
     *
     * @type {Array<string>}
     * @memberof Favorite
     */
    'tags': Array<string>;
    /**
     *
     * @type {FavoriteType}
     * @memberof Favorite
     */
    'type': FavoriteType;
}
/**
 *
 * @export
 * @interface FavoriteGroup
 */
export interface FavoriteGroup {
    /**
     *
     * @type {string}
     * @memberof FavoriteGroup
     */
    'displayName': string;
    /**
     *
     * @type {string}
     * @memberof FavoriteGroup
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof FavoriteGroup
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof FavoriteGroup
     */
    'ownerDisplayName': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof FavoriteGroup
     */
    'ownerId': string;
    /**
     *
     * @type {Array<string>}
     * @memberof FavoriteGroup
     */
    'tags': Array<string>;
    /**
     *
     * @type {FavoriteType}
     * @memberof FavoriteGroup
     */
    'type': FavoriteType;
    /**
     *
     * @type {FavoriteGroupVisibility}
     * @memberof FavoriteGroup
     */
    'visibility': FavoriteGroupVisibility;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const FavoriteGroupVisibility: {
    readonly Private: "private";
    readonly Friends: "friends";
    readonly Public: "public";
};
export type FavoriteGroupVisibility = typeof FavoriteGroupVisibility[keyof typeof FavoriteGroupVisibility];
/**
 *
 * @export
 * @enum {string}
 */
export declare const FavoriteType: {
    readonly World: "world";
    readonly Friend: "friend";
    readonly Avatar: "avatar";
};
export type FavoriteType = typeof FavoriteType[keyof typeof FavoriteType];
/**
 *
 * @export
 * @interface FileData
 */
export interface FileData {
    /**
     *
     * @type {string}
     * @memberof FileData
     */
    'category': FileDataCategoryEnum;
    /**
     *
     * @type {string}
     * @memberof FileData
     */
    'fileName': string;
    /**
     *
     * @type {string}
     * @memberof FileData
     */
    'md5': string;
    /**
     *
     * @type {number}
     * @memberof FileData
     */
    'sizeInBytes': number;
    /**
     *
     * @type {FileStatus}
     * @memberof FileData
     */
    'status': FileStatus;
    /**
     *
     * @type {string}
     * @memberof FileData
     */
    'uploadId': string;
    /**
     *
     * @type {string}
     * @memberof FileData
     */
    'url': string;
}
export declare const FileDataCategoryEnum: {
    readonly Multipart: "multipart";
    readonly Queued: "queued";
    readonly Simple: "simple";
};
export type FileDataCategoryEnum = typeof FileDataCategoryEnum[keyof typeof FileDataCategoryEnum];
/**
 *
 * @export
 * @enum {string}
 */
export declare const FileStatus: {
    readonly Waiting: "waiting";
    readonly Complete: "complete";
    readonly None: "none";
    readonly Queued: "queued";
};
export type FileStatus = typeof FileStatus[keyof typeof FileStatus];
/**
 *
 * @export
 * @interface FileUploadURL
 */
export interface FileUploadURL {
    /**
     *
     * @type {string}
     * @memberof FileUploadURL
     */
    'url': string;
}
/**
 *
 * @export
 * @interface FileVersion
 */
export interface FileVersion {
    /**
     *
     * @type {string}
     * @memberof FileVersion
     */
    'created_at': string;
    /**
     * Usually only present if `true`
     * @type {boolean}
     * @memberof FileVersion
     */
    'deleted'?: boolean;
    /**
     *
     * @type {FileData}
     * @memberof FileVersion
     */
    'delta'?: FileData;
    /**
     *
     * @type {FileData}
     * @memberof FileVersion
     */
    'file'?: FileData;
    /**
     *
     * @type {FileData}
     * @memberof FileVersion
     */
    'signature'?: FileData;
    /**
     *
     * @type {FileStatus}
     * @memberof FileVersion
     */
    'status': FileStatus;
    /**
     * Incremental version counter, can only be increased.
     * @type {number}
     * @memberof FileVersion
     */
    'version': number;
}
/**
 *
 * @export
 * @interface FileVersionUploadStatus
 */
export interface FileVersionUploadStatus {
    /**
     *
     * @type {string}
     * @memberof FileVersionUploadStatus
     */
    'uploadId': string;
    /**
     *
     * @type {string}
     * @memberof FileVersionUploadStatus
     */
    'fileName': string;
    /**
     *
     * @type {number}
     * @memberof FileVersionUploadStatus
     */
    'nextPartNumber': number;
    /**
     *
     * @type {number}
     * @memberof FileVersionUploadStatus
     */
    'maxParts': number;
    /**
     *
     * @type {Array<object>}
     * @memberof FileVersionUploadStatus
     */
    'parts': Array<object>;
    /**
     * Unknown
     * @type {Array<object>}
     * @memberof FileVersionUploadStatus
     */
    'etags': Array<object>;
}
/**
 *
 * @export
 * @interface FinishFileDataUploadRequest
 */
export interface FinishFileDataUploadRequest {
    /**
     * Array of ETags uploaded.
     * @type {Set<string>}
     * @memberof FinishFileDataUploadRequest
     */
    'etags'?: Set<string>;
    /**
     * Always a zero in string form, despite how many parts uploaded.
     * @type {string}
     * @memberof FinishFileDataUploadRequest
     * @deprecated
     */
    'nextPartNumber': string;
    /**
     * Always a zero in string form, despite how many parts uploaded.
     * @type {string}
     * @memberof FinishFileDataUploadRequest
     * @deprecated
     */
    'maxParts': string;
}
/**
 *
 * @export
 * @interface FriendStatus
 */
export interface FriendStatus {
    /**
     *
     * @type {boolean}
     * @memberof FriendStatus
     */
    'incomingRequest': boolean;
    /**
     *
     * @type {boolean}
     * @memberof FriendStatus
     */
    'isFriend': boolean;
    /**
     *
     * @type {boolean}
     * @memberof FriendStatus
     */
    'outgoingRequest': boolean;
}
/**
 *
 * @export
 * @interface Group
 */
export interface Group {
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'shortCode'?: string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'discriminator'?: string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'iconUrl'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'bannerUrl'?: string | null;
    /**
     *
     * @type {GroupPrivacy}
     * @memberof Group
     */
    'privacy'?: GroupPrivacy;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Group
     */
    'ownerId'?: string;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'rules'?: string | null;
    /**
     *
     * @type {Array<string>}
     * @memberof Group
     */
    'links'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof Group
     */
    'languages'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'iconId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'bannerId'?: string | null;
    /**
     *
     * @type {number}
     * @memberof Group
     */
    'memberCount'?: number;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'memberCountSyncedAt'?: string;
    /**
     *
     * @type {boolean}
     * @memberof Group
     */
    'isVerified'?: boolean;
    /**
     *
     * @type {GroupJoinState}
     * @memberof Group
     */
    'joinState'?: GroupJoinState;
    /**
     *
     * @type {Array<string>}
     * @memberof Group
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {Array<GroupGallery>}
     * @memberof Group
     */
    'galleries'?: Array<GroupGallery>;
    /**
     *
     * @type {string}
     * @memberof Group
     */
    'createdAt'?: string;
    /**
     *
     * @type {number}
     * @memberof Group
     */
    'onlineMemberCount'?: number;
    /**
     *
     * @type {GroupMemberStatus}
     * @memberof Group
     */
    'membershipStatus'?: GroupMemberStatus;
    /**
     *
     * @type {GroupMyMember}
     * @memberof Group
     */
    'myMember'?: GroupMyMember;
    /**
     * Only returned if ?includeRoles=true is specified.
     * @type {Array<GroupRole>}
     * @memberof Group
     */
    'roles'?: Array<GroupRole> | null;
}
/**
 *
 * @export
 * @interface GroupAnnouncement
 */
export interface GroupAnnouncement {
    /**
     *
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'authorId'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'title'?: string | null;
    /**
     *
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'text'?: string | null;
    /**
     *
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'imageId'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'imageUrl'?: string | null;
    /**
     *
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'createdAt'?: string | null;
    /**
     *
     * @type {string}
     * @memberof GroupAnnouncement
     */
    'updatedAt'?: string | null;
}
/**
 *
 * @export
 * @interface GroupAuditLogEntry
 */
export interface GroupAuditLogEntry {
    /**
     *
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'created_at'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'actorId'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'actorDisplayname'?: string;
    /**
     * Typically GroupID or GroupRoleID, but could be other types of IDs.
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'targetId'?: string;
    /**
     * The type of event that occurred. This is a string that is prefixed with the type of object that the event occurred on. For example, a group role update event would be prefixed with `group.role`.
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'eventType'?: string;
    /**
     * A human-readable description of the event.
     * @type {string}
     * @memberof GroupAuditLogEntry
     */
    'description'?: string;
    /**
     * The data associated with the event. The format of this data is dependent on the event type.
     * @type {object}
     * @memberof GroupAuditLogEntry
     */
    'data'?: object;
}
/**
 *
 * @export
 * @interface GroupGallery
 */
export interface GroupGallery {
    /**
     *
     * @type {string}
     * @memberof GroupGallery
     */
    'id'?: string;
    /**
     * Name of the gallery.
     * @type {string}
     * @memberof GroupGallery
     */
    'name'?: string;
    /**
     * Description of the gallery.
     * @type {string}
     * @memberof GroupGallery
     */
    'description'?: string;
    /**
     * Whether the gallery is members only.
     * @type {boolean}
     * @memberof GroupGallery
     */
    'membersOnly'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof GroupGallery
     */
    'roleIdsToView'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof GroupGallery
     */
    'roleIdsToSubmit'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof GroupGallery
     */
    'roleIdsToAutoApprove'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof GroupGallery
     */
    'roleIdsToManage'?: Array<string> | null;
    /**
     *
     * @type {string}
     * @memberof GroupGallery
     */
    'createdAt'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupGallery
     */
    'updatedAt'?: string;
}
/**
 *
 * @export
 * @interface GroupGalleryImage
 */
export interface GroupGalleryImage {
    /**
     *
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'groupId'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'galleryId'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'fileId'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'imageUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'createdAt'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'submittedByUserId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof GroupGalleryImage
     */
    'approved'?: boolean;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'approvedByUserId'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupGalleryImage
     */
    'approvedAt'?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const GroupJoinState: {
    readonly Closed: "closed";
    readonly Invite: "invite";
    readonly Request: "request";
    readonly Open: "open";
};
export type GroupJoinState = typeof GroupJoinState[keyof typeof GroupJoinState];
/**
 *
 * @export
 * @interface GroupLimitedMember
 */
export interface GroupLimitedMember {
    /**
     *
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupLimitedMember
     */
    'userId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof GroupLimitedMember
     */
    'isRepresenting'?: boolean;
}
/**
 *
 * @export
 * @interface GroupMember
 */
export interface GroupMember {
    /**
     *
     * @type {string}
     * @memberof GroupMember
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMember
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupMember
     */
    'userId'?: string;
    /**
     * Whether the user is representing the group. This makes the group show up above the name tag in-game.
     * @type {boolean}
     * @memberof GroupMember
     */
    'isRepresenting'?: boolean;
    /**
     *
     * @type {GroupMemberLimitedUser}
     * @memberof GroupMember
     */
    'user'?: GroupMemberLimitedUser;
    /**
     *
     * @type {Array<string>}
     * @memberof GroupMember
     */
    'roleIds'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof GroupMember
     */
    'joinedAt'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMember
     */
    'membershipStatus'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMember
     */
    'visibility'?: string;
    /**
     *
     * @type {boolean}
     * @memberof GroupMember
     */
    'isSubscribedToAnnouncements'?: boolean;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupMember
     */
    'createdAt'?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupMember
     */
    'bannedAt'?: string | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     * @type {string}
     * @memberof GroupMember
     */
    'managerNotes'?: string | null;
}
/**
 * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
 * @export
 * @interface GroupMemberLimitedUser
 */
export interface GroupMemberLimitedUser {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'displayName'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'thumbnailUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMemberLimitedUser
     */
    'iconUrl'?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const GroupMemberStatus: {
    readonly Inactive: "inactive";
    readonly Member: "member";
    readonly Requested: "requested";
    readonly Invited: "invited";
};
export type GroupMemberStatus = typeof GroupMemberStatus[keyof typeof GroupMemberStatus];
/**
 *
 * @export
 * @interface GroupMyMember
 */
export interface GroupMyMember {
    /**
     *
     * @type {string}
     * @memberof GroupMyMember
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMyMember
     */
    'groupId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof GroupMyMember
     */
    'userId'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof GroupMyMember
     */
    'roleIds'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof GroupMyMember
     */
    'managerNotes'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMyMember
     */
    'membershipStatus'?: string;
    /**
     *
     * @type {boolean}
     * @memberof GroupMyMember
     */
    'isSubscribedToAnnouncements'?: boolean;
    /**
     *
     * @type {string}
     * @memberof GroupMyMember
     */
    'visibility'?: string;
    /**
     *
     * @type {boolean}
     * @memberof GroupMyMember
     */
    'isRepresenting'?: boolean;
    /**
     *
     * @type {string}
     * @memberof GroupMyMember
     */
    'joinedAt'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupMyMember
     */
    'bannedAt'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof GroupMyMember
     */
    'has2FA'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof GroupMyMember
     */
    'permissions'?: Array<string>;
}
/**
 * A permission that can be granted to a role in a group.
 * @export
 * @interface GroupPermission
 */
export interface GroupPermission {
    /**
     * The name of the permission.
     * @type {string}
     * @memberof GroupPermission
     */
    'name'?: string;
    /**
     * The display name of the permission.
     * @type {string}
     * @memberof GroupPermission
     */
    'displayName'?: string;
    /**
     * Human-readable description of the permission.
     * @type {string}
     * @memberof GroupPermission
     */
    'help'?: string;
    /**
     * Whether this permission is a \"management\" permission.
     * @type {boolean}
     * @memberof GroupPermission
     */
    'isManagementPermission'?: boolean;
    /**
     * Whether the user is allowed to add this permission to a role.
     * @type {boolean}
     * @memberof GroupPermission
     */
    'allowedToAdd'?: boolean;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const GroupPrivacy: {
    readonly Default: "default";
    readonly Private: "private";
};
export type GroupPrivacy = typeof GroupPrivacy[keyof typeof GroupPrivacy];
/**
 *
 * @export
 * @interface GroupRole
 */
export interface GroupRole {
    /**
     *
     * @type {string}
     * @memberof GroupRole
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupRole
     */
    'groupId'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupRole
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupRole
     */
    'description'?: string;
    /**
     *
     * @type {boolean}
     * @memberof GroupRole
     */
    'isSelfAssignable'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof GroupRole
     */
    'permissions'?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof GroupRole
     */
    'isManagementRole'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupRole
     */
    'requiresTwoFactor'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof GroupRole
     */
    'requiresPurchase'?: boolean;
    /**
     *
     * @type {number}
     * @memberof GroupRole
     */
    'order'?: number;
    /**
     *
     * @type {string}
     * @memberof GroupRole
     */
    'createdAt'?: string;
    /**
     *
     * @type {string}
     * @memberof GroupRole
     */
    'updatedAt'?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const GroupRoleTemplate: {
    readonly Default: "default";
    readonly ManagedFree: "managedFree";
    readonly ManagedInvite: "managedInvite";
    readonly ManagedRequest: "managedRequest";
};
export type GroupRoleTemplate = typeof GroupRoleTemplate[keyof typeof GroupRoleTemplate];
/**
 *
 * @export
 * @enum {string}
 */
export declare const GroupUserVisibility: {
    readonly Visible: "visible";
    readonly Hidden: "hidden";
    readonly Friends: "friends";
};
export type GroupUserVisibility = typeof GroupUserVisibility[keyof typeof GroupUserVisibility];
/**
 *
 * @export
 * @interface InfoPush
 */
export interface InfoPush {
    /**
     *
     * @type {string}
     * @memberof InfoPush
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof InfoPush
     */
    'isEnabled': boolean;
    /**
     *
     * @type {ReleaseStatus}
     * @memberof InfoPush
     */
    'releaseStatus': ReleaseStatus;
    /**
     *
     * @type {number}
     * @memberof InfoPush
     */
    'priority': number;
    /**
     *
     * @type {Array<string>}
     * @memberof InfoPush
     */
    'tags': Array<string>;
    /**
     *
     * @type {InfoPushData}
     * @memberof InfoPush
     */
    'data': InfoPushData;
    /**
     * Unknown usage, MD5
     * @type {string}
     * @memberof InfoPush
     */
    'hash': string;
    /**
     *
     * @type {string}
     * @memberof InfoPush
     */
    'createdAt': string;
    /**
     *
     * @type {string}
     * @memberof InfoPush
     */
    'updatedAt': string;
    /**
     *
     * @type {string}
     * @memberof InfoPush
     */
    'startDate'?: string;
    /**
     *
     * @type {string}
     * @memberof InfoPush
     */
    'endDate'?: string;
}
/**
 *
 * @export
 * @interface InfoPushData
 */
export interface InfoPushData {
    /**
     *
     * @type {DynamicContentRow}
     * @memberof InfoPushData
     */
    'contentList'?: DynamicContentRow;
    /**
     *
     * @type {string}
     * @memberof InfoPushData
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof InfoPushData
     */
    'imageUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof InfoPushData
     */
    'name'?: string;
    /**
     *
     * @type {InfoPushDataClickable}
     * @memberof InfoPushData
     */
    'onPressed'?: InfoPushDataClickable;
    /**
     *
     * @type {string}
     * @memberof InfoPushData
     */
    'template'?: string;
    /**
     *
     * @type {string}
     * @memberof InfoPushData
     */
    'version'?: string;
    /**
     *
     * @type {InfoPushDataArticle}
     * @memberof InfoPushData
     */
    'article'?: InfoPushDataArticle;
}
/**
 *
 * @export
 * @interface InfoPushDataArticle
 */
export interface InfoPushDataArticle {
    /**
     *
     * @type {InfoPushDataArticleContent}
     * @memberof InfoPushDataArticle
     */
    'content'?: InfoPushDataArticleContent;
}
/**
 *
 * @export
 * @interface InfoPushDataArticleContent
 */
export interface InfoPushDataArticleContent {
    /**
     *
     * @type {string}
     * @memberof InfoPushDataArticleContent
     */
    'text'?: string;
    /**
     *
     * @type {string}
     * @memberof InfoPushDataArticleContent
     */
    'imageUrl'?: string;
    /**
     *
     * @type {InfoPushDataClickable}
     * @memberof InfoPushDataArticleContent
     */
    'onPressed'?: InfoPushDataClickable;
}
/**
 *
 * @export
 * @interface InfoPushDataClickable
 */
export interface InfoPushDataClickable {
    /**
     *
     * @type {string}
     * @memberof InfoPushDataClickable
     */
    'command': InfoPushDataClickableCommandEnum;
    /**
     * In case of OpenURL, this would contain the link.
     * @type {Array<string>}
     * @memberof InfoPushDataClickable
     */
    'parameters'?: Array<string>;
}
export declare const InfoPushDataClickableCommandEnum: {
    readonly OpenUrl: "OpenURL";
    readonly OpenVrcPlusMenu: "OpenVRCPlusMenu";
    readonly OpenSafetyMenu: "OpenSafetyMenu";
    readonly CannedWorldSearch: "CannedWorldSearch";
};
export type InfoPushDataClickableCommandEnum = typeof InfoPushDataClickableCommandEnum[keyof typeof InfoPushDataClickableCommandEnum];
/**
 * * `hidden` field is only present if InstanceType is `hidden` aka \"Friends+\", and is instance creator. * `friends` field is only present if InstanceType is `friends` aka \"Friends\", and is instance creator. * `private` field is only present if InstanceType is `private` aka \"Invite\" or \"Invite+\", and is instance creator.
 * @export
 * @interface Instance
 */
export interface Instance {
    /**
     *
     * @type {boolean}
     * @memberof Instance
     */
    'active': boolean;
    /**
     *
     * @type {boolean}
     * @memberof Instance
     */
    'canRequestInvite': boolean;
    /**
     *
     * @type {number}
     * @memberof Instance
     */
    'capacity': number;
    /**
     * Always returns \"unknown\".
     * @type {string}
     * @memberof Instance
     * @deprecated
     */
    'clientNumber': string;
    /**
     *
     * @type {boolean}
     * @memberof Instance
     */
    'full': boolean;
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof Instance
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Instance
     */
    'instanceId': string;
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof Instance
     */
    'location': string;
    /**
     *
     * @type {number}
     * @memberof Instance
     */
    'n_users': number;
    /**
     *
     * @type {string}
     * @memberof Instance
     */
    'name': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Instance
     */
    'ownerId'?: string;
    /**
     *
     * @type {boolean}
     * @memberof Instance
     */
    'permanent': boolean;
    /**
     *
     * @type {Region}
     * @memberof Instance
     */
    'photonRegion': Region;
    /**
     *
     * @type {InstancePlatforms}
     * @memberof Instance
     */
    'platforms': InstancePlatforms;
    /**
     *
     * @type {Region}
     * @memberof Instance
     */
    'region': Region;
    /**
     *
     * @type {string}
     * @memberof Instance
     */
    'secureName': string;
    /**
     *
     * @type {string}
     * @memberof Instance
     */
    'shortName'?: string;
    /**
     * The tags array on Instances usually contain the language tags of the people in the instance.
     * @type {Array<string>}
     * @memberof Instance
     */
    'tags': Array<string>;
    /**
     *
     * @type {InstanceType}
     * @memberof Instance
     */
    'type': InstanceType;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof Instance
     */
    'worldId': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Instance
     */
    'hidden'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Instance
     */
    'friends'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Instance
     */
    'private'?: string;
}
/**
 *
 * @export
 * @interface InstancePlatforms
 */
export interface InstancePlatforms {
    /**
     *
     * @type {number}
     * @memberof InstancePlatforms
     */
    'android': number;
    /**
     *
     * @type {number}
     * @memberof InstancePlatforms
     */
    'standalonewindows': number;
}
/**
 *
 * @export
 * @interface InstanceShortNameResponse
 */
export interface InstanceShortNameResponse {
    /**
     *
     * @type {string}
     * @memberof InstanceShortNameResponse
     */
    'secureName': string;
    /**
     *
     * @type {string}
     * @memberof InstanceShortNameResponse
     */
    'shortName'?: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const InstanceType: {
    readonly Public: "public";
    readonly Hidden: "hidden";
    readonly Friends: "friends";
    readonly Private: "private";
};
export type InstanceType = typeof InstanceType[keyof typeof InstanceType];
/**
 *
 * @export
 * @interface InviteMessage
 */
export interface InviteMessage {
    /**
     *
     * @type {boolean}
     * @memberof InviteMessage
     */
    'canBeUpdated': boolean;
    /**
     *
     * @type {string}
     * @memberof InviteMessage
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof InviteMessage
     */
    'message': string;
    /**
     *
     * @type {InviteMessageType}
     * @memberof InviteMessage
     */
    'messageType': InviteMessageType;
    /**
     * Changes to 60 when updated, although probably server-side configurable.
     * @type {number}
     * @memberof InviteMessage
     */
    'remainingCooldownMinutes': number;
    /**
     *
     * @type {number}
     * @memberof InviteMessage
     */
    'slot': number;
    /**
     *
     * @type {string}
     * @memberof InviteMessage
     */
    'updatedAt': string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const InviteMessageType: {
    readonly Message: "message";
    readonly Response: "response";
    readonly Request: "request";
    readonly RequestResponse: "requestResponse";
};
export type InviteMessageType = typeof InviteMessageType[keyof typeof InviteMessageType];
/**
 *
 * @export
 * @interface InviteRequest
 */
export interface InviteRequest {
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof InviteRequest
     */
    'instanceId': string;
    /**
     *
     * @type {number}
     * @memberof InviteRequest
     */
    'messageSlot'?: number;
}
/**
 *
 * @export
 * @interface InviteResponse
 */
export interface InviteResponse {
    /**
     *
     * @type {number}
     * @memberof InviteResponse
     */
    'responseSlot': number;
}
/**
 *
 * @export
 * @interface License
 */
export interface License {
    /**
     * Either a AvatarID, LicenseGroupID, PermissionID or ProductID. This depends on the `forType` field.
     * @type {string}
     * @memberof License
     */
    'forId': string;
    /**
     *
     * @type {LicenseType}
     * @memberof License
     */
    'forType': LicenseType;
    /**
     *
     * @type {string}
     * @memberof License
     */
    'forName': string;
    /**
     *
     * @type {LicenseAction}
     * @memberof License
     */
    'forAction': LicenseAction;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const LicenseAction: {
    readonly Wear: "wear";
    readonly Have: "have";
};
export type LicenseAction = typeof LicenseAction[keyof typeof LicenseAction];
/**
 *
 * @export
 * @interface LicenseGroup
 */
export interface LicenseGroup {
    /**
     *
     * @type {string}
     * @memberof LicenseGroup
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof LicenseGroup
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof LicenseGroup
     */
    'description': string;
    /**
     *
     * @type {Array<License>}
     * @memberof LicenseGroup
     */
    'licenses': Array<License>;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const LicenseType: {
    readonly Avatar: "avatar";
    readonly LicenseGroup: "licenseGroup";
    readonly Permission: "permission";
    readonly Product: "product";
};
export type LicenseType = typeof LicenseType[keyof typeof LicenseType];
/**
 *
 * @export
 * @interface LimitedUnityPackage
 */
export interface LimitedUnityPackage {
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof LimitedUnityPackage
     */
    'platform': string;
    /**
     *
     * @type {string}
     * @memberof LimitedUnityPackage
     */
    'unityVersion': string;
}
/**
 *
 * @export
 * @interface LimitedUser
 */
export interface LimitedUser {
    /**
     *
     * @type {string}
     * @memberof LimitedUser
     */
    'bio'?: string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof LimitedUser
     */
    'currentAvatarImageUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof LimitedUser
     */
    'currentAvatarThumbnailImageUrl': string;
    /**
     *
     * @type {DeveloperType}
     * @memberof LimitedUser
     */
    'developerType': DeveloperType;
    /**
     *
     * @type {string}
     * @memberof LimitedUser
     */
    'displayName': string;
    /**
     *
     * @type {string}
     * @memberof LimitedUser
     */
    'fallbackAvatar': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof LimitedUser
     */
    'id': string;
    /**
     *
     * @type {boolean}
     * @memberof LimitedUser
     */
    'isFriend': boolean;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof LimitedUser
     */
    'last_platform': string;
    /**
     *
     * @type {string}
     * @memberof LimitedUser
     */
    'profilePicOverride': string;
    /**
     *
     * @type {UserStatus}
     * @memberof LimitedUser
     */
    'status': UserStatus;
    /**
     *
     * @type {string}
     * @memberof LimitedUser
     */
    'statusDescription': string;
    /**
     * <- Always empty.
     * @type {Array<string>}
     * @memberof LimitedUser
     */
    'tags': Array<string>;
    /**
     *
     * @type {string}
     * @memberof LimitedUser
     */
    'userIcon': string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof LimitedUser
     * @deprecated
     */
    'username'?: string;
    /**
     *
     * @type {string}
     * @memberof LimitedUser
     */
    'location'?: string;
    /**
     *
     * @type {string}
     * @memberof LimitedUser
     */
    'friendKey'?: string;
}
/**
 *
 * @export
 * @interface LimitedWorld
 */
export interface LimitedWorld {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof LimitedWorld
     */
    'authorId': string;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'authorName': string;
    /**
     *
     * @type {number}
     * @memberof LimitedWorld
     */
    'capacity': number;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'created_at': string;
    /**
     *
     * @type {number}
     * @memberof LimitedWorld
     */
    'favorites': number;
    /**
     *
     * @type {number}
     * @memberof LimitedWorld
     */
    'heat': number;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof LimitedWorld
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'imageUrl': string;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'labsPublicationDate': string;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'name': string;
    /**
     *
     * @type {number}
     * @memberof LimitedWorld
     */
    'occupants': number;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'organization': string;
    /**
     *
     * @type {number}
     * @memberof LimitedWorld
     */
    'popularity': number;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'publicationDate': string;
    /**
     *
     * @type {ReleaseStatus}
     * @memberof LimitedWorld
     */
    'releaseStatus': ReleaseStatus;
    /**
     *
     * @type {Array<string>}
     * @memberof LimitedWorld
     */
    'tags': Array<string>;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'thumbnailImageUrl': string;
    /**
     *
     * @type {Array<LimitedUnityPackage>}
     * @memberof LimitedWorld
     */
    'unityPackages': Array<LimitedUnityPackage>;
    /**
     *
     * @type {string}
     * @memberof LimitedWorld
     */
    'updated_at': string;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const MIMEType: {
    readonly ImageJpeg: "image/jpeg";
    readonly ImageJpg: "image/jpg";
    readonly ImagePng: "image/png";
    readonly ImageWebp: "image/webp";
    readonly ImageGif: "image/gif";
    readonly ImageBmp: "image/bmp";
    readonly ImageSvgxml: "image/svgxml";
    readonly ImageTiff: "image/tiff";
    readonly ApplicationXAvatar: "application/x-avatar";
    readonly ApplicationXWorld: "application/x-world";
    readonly ApplicationGzip: "application/gzip";
    readonly ApplicationXRsyncSignature: "application/x-rsync-signature";
    readonly ApplicationXRsyncDelta: "application/x-rsync-delta";
    readonly ApplicationOctetStream: "application/octet-stream";
};
export type MIMEType = typeof MIMEType[keyof typeof MIMEType];
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {Response}
     * @memberof ModelError
     */
    'error'?: Response;
}
/**
 *
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     *
     * @type {string}
     * @memberof ModelFile
     */
    'extension': string;
    /**
     *
     * @type {string}
     * @memberof ModelFile
     */
    'id': string;
    /**
     *
     * @type {MIMEType}
     * @memberof ModelFile
     */
    'mimeType': MIMEType;
    /**
     *
     * @type {string}
     * @memberof ModelFile
     */
    'name': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof ModelFile
     */
    'ownerId': string;
    /**
     *
     * @type {Array<string>}
     * @memberof ModelFile
     */
    'tags': Array<string>;
    /**
     *
     * @type {Set<FileVersion>}
     * @memberof ModelFile
     */
    'versions': Set<FileVersion>;
}
/**
 *
 * @export
 * @interface ModerateUserRequest
 */
export interface ModerateUserRequest {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof ModerateUserRequest
     */
    'moderated': string;
    /**
     *
     * @type {PlayerModerationType}
     * @memberof ModerateUserRequest
     */
    'type': PlayerModerationType;
}
/**
 *
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    'created_at': string;
    /**
     * **NOTICE:** This is not a JSON object when received from the REST API, but it is when received from the Websocket API. When received from the REST API, this is a json **encoded** object, meaning you have to json-de-encode to get the NotificationDetail object depending on the NotificationType.
     * @type {string}
     * @memberof Notification
     */
    'details': string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    'message': string;
    /**
     * Not included in notification objects received from the Websocket API
     * @type {boolean}
     * @memberof Notification
     */
    'seen'?: boolean;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Notification
     */
    'receiverUserId'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Notification
     */
    'senderUserId': string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof Notification
     * @deprecated
     */
    'senderUsername'?: string;
    /**
     *
     * @type {NotificationType}
     * @memberof Notification
     */
    'type': NotificationType;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const NotificationType: {
    readonly FriendRequest: "friendRequest";
    readonly Invite: "invite";
    readonly InviteResponse: "inviteResponse";
    readonly RequestInvite: "requestInvite";
    readonly RequestInviteResponse: "requestInviteResponse";
    readonly Votetokick: "votetokick";
};
export type NotificationType = typeof NotificationType[keyof typeof NotificationType];
/**
 *
 * @export
 * @enum {string}
 */
export declare const OrderOption: {
    readonly Ascending: "ascending";
    readonly Descending: "descending";
};
export type OrderOption = typeof OrderOption[keyof typeof OrderOption];
/**
 *
 * @export
 * @interface PaginatedGroupAuditLogEntryList
 */
export interface PaginatedGroupAuditLogEntryList {
    /**
     *
     * @type {Array<GroupAuditLogEntry>}
     * @memberof PaginatedGroupAuditLogEntryList
     */
    'results'?: Array<GroupAuditLogEntry>;
    /**
     * The total number of results that the query would return if there were no pagination.
     * @type {number}
     * @memberof PaginatedGroupAuditLogEntryList
     */
    'totalCount'?: number;
    /**
     * Whether there are more results after this page.
     * @type {boolean}
     * @memberof PaginatedGroupAuditLogEntryList
     */
    'hasNext'?: boolean;
}
/**
 *
 * @export
 * @interface PastDisplayName
 */
export interface PastDisplayName {
    /**
     *
     * @type {string}
     * @memberof PastDisplayName
     */
    'displayName': string;
    /**
     *
     * @type {string}
     * @memberof PastDisplayName
     */
    'updated_at': string;
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Permission
     */
    'name': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof Permission
     */
    'ownerId': string;
    /**
     *
     * @type {object}
     * @memberof Permission
     */
    'data'?: object;
}
/**
 *
 * @export
 * @interface PlayerModeration
 */
export interface PlayerModeration {
    /**
     *
     * @type {string}
     * @memberof PlayerModeration
     */
    'created': string;
    /**
     *
     * @type {string}
     * @memberof PlayerModeration
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof PlayerModeration
     */
    'sourceDisplayName': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof PlayerModeration
     */
    'sourceUserId': string;
    /**
     *
     * @type {string}
     * @memberof PlayerModeration
     */
    'targetDisplayName': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof PlayerModeration
     */
    'targetUserId': string;
    /**
     *
     * @type {PlayerModerationType}
     * @memberof PlayerModeration
     */
    'type': PlayerModerationType;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const PlayerModerationType: {
    readonly Mute: "mute";
    readonly Unmute: "unmute";
    readonly Block: "block";
    readonly Unblock: "unblock";
    readonly InteractOn: "interactOn";
    readonly InteractOff: "interactOff";
};
export type PlayerModerationType = typeof PlayerModerationType[keyof typeof PlayerModerationType];
/**
 * API/Photon region.
 * @export
 * @enum {string}
 */
export declare const Region: {
    readonly Us: "us";
    readonly Use: "use";
    readonly Usw: "usw";
    readonly Eu: "eu";
    readonly Jp: "jp";
    readonly Unknown: "unknown";
};
export type Region = typeof Region[keyof typeof Region];
/**
 *
 * @export
 * @enum {string}
 */
export declare const ReleaseStatus: {
    readonly Public: "public";
    readonly Private: "private";
    readonly Hidden: "hidden";
};
export type ReleaseStatus = typeof ReleaseStatus[keyof typeof ReleaseStatus];
/**
 *
 * @export
 * @interface RequestInviteRequest
 */
export interface RequestInviteRequest {
    /**
     *
     * @type {number}
     * @memberof RequestInviteRequest
     */
    'messageSlot'?: number;
}
/**
 *
 * @export
 * @interface RespondGroupJoinRequest
 */
export interface RespondGroupJoinRequest {
    /**
     *
     * @type {string}
     * @memberof RespondGroupJoinRequest
     */
    'action'?: string;
}
/**
 *
 * @export
 * @interface Response
 */
export interface Response {
    /**
     *
     * @type {string}
     * @memberof Response
     */
    'message'?: string;
    /**
     *
     * @type {number}
     * @memberof Response
     */
    'status_code': number;
}
/**
 *
 * @export
 * @interface SentNotification
 */
export interface SentNotification {
    /**
     *
     * @type {string}
     * @memberof SentNotification
     */
    'created_at': string;
    /**
     * **NOTICE:** This is not a JSON object, this is a json **encoded** object, meaning you have to json-de-encode to get the NotificationDetail object depending on the NotificationType.
     * @type {string}
     * @memberof SentNotification
     */
    'details': string;
    /**
     *
     * @type {string}
     * @memberof SentNotification
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof SentNotification
     */
    'message': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof SentNotification
     */
    'recieverUserId': string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof SentNotification
     */
    'senderUserId': string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof SentNotification
     * @deprecated
     */
    'senderUsername'?: string;
    /**
     *
     * @type {NotificationType}
     * @memberof SentNotification
     */
    'type': NotificationType;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const SortOption: {
    readonly Popularity: "popularity";
    readonly Heat: "heat";
    readonly Trust: "trust";
    readonly Shuffle: "shuffle";
    readonly Random: "random";
    readonly Favorites: "favorites";
    readonly ReportScore: "reportScore";
    readonly ReportCount: "reportCount";
    readonly PublicationDate: "publicationDate";
    readonly LabsPublicationDate: "labsPublicationDate";
    readonly Created: "created";
    readonly CreatedAt: "_created_at";
    readonly Updated: "updated";
    readonly UpdatedAt: "_updated_at";
    readonly Order: "order";
    readonly Relevance: "relevance";
    readonly Magic: "magic";
    readonly Name: "name";
};
export type SortOption = typeof SortOption[keyof typeof SortOption];
/**
 *
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     *
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof Subscription
     */
    'steamItemId': string;
    /**
     *
     * @type {number}
     * @memberof Subscription
     */
    'amount': number;
    /**
     *
     * @type {string}
     * @memberof Subscription
     */
    'description': string;
    /**
     *
     * @type {SubscriptionPeriod}
     * @memberof Subscription
     */
    'period': SubscriptionPeriod;
    /**
     *
     * @type {number}
     * @memberof Subscription
     */
    'tier': number;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const SubscriptionPeriod: {
    readonly Hour: "hour";
    readonly Day: "day";
    readonly Week: "week";
    readonly Month: "month";
    readonly Year: "year";
};
export type SubscriptionPeriod = typeof SubscriptionPeriod[keyof typeof SubscriptionPeriod];
/**
 *
 * @export
 * @interface Success
 */
export interface Success {
    /**
     *
     * @type {Response}
     * @memberof Success
     */
    'success'?: Response;
}
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     *
     * @type {TransactionStatus}
     * @memberof Transaction
     */
    'status': TransactionStatus;
    /**
     *
     * @type {Subscription}
     * @memberof Transaction
     */
    'subscription': Subscription;
    /**
     *
     * @type {boolean}
     * @memberof Transaction
     */
    'sandbox': boolean;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    'updated_at': string;
    /**
     *
     * @type {TransactionSteamInfo}
     * @memberof Transaction
     */
    'steam'?: TransactionSteamInfo;
    /**
     *
     * @type {TransactionAgreement}
     * @memberof Transaction
     */
    'agreement'?: TransactionAgreement;
    /**
     *
     * @type {string}
     * @memberof Transaction
     */
    'error': string;
}
/**
 *
 * @export
 * @interface TransactionAgreement
 */
export interface TransactionAgreement {
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'agreementId': string;
    /**
     *
     * @type {number}
     * @memberof TransactionAgreement
     */
    'itemId': number;
    /**
     * This is NOT TransactionStatus, but whatever Steam return.
     * @type {string}
     * @memberof TransactionAgreement
     */
    'status': string;
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'period': string;
    /**
     *
     * @type {number}
     * @memberof TransactionAgreement
     */
    'frequency': number;
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'billingType': string;
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'startDate': string;
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'endDate': string;
    /**
     *
     * @type {number}
     * @memberof TransactionAgreement
     */
    'recurringAmt': number;
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'currency': string;
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'timeCreated': string;
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'nextPayment': string;
    /**
     *
     * @type {string}
     * @memberof TransactionAgreement
     */
    'lastPayment': string;
    /**
     *
     * @type {number}
     * @memberof TransactionAgreement
     */
    'lastAmount': number;
    /**
     *
     * @type {number}
     * @memberof TransactionAgreement
     */
    'lastAmountVat': number;
    /**
     *
     * @type {number}
     * @memberof TransactionAgreement
     */
    'outstanding': number;
    /**
     *
     * @type {number}
     * @memberof TransactionAgreement
     */
    'failedAttempts': number;
}
/**
 *
 * @export
 * @enum {string}
 */
export declare const TransactionStatus: {
    readonly Active: "active";
    readonly Failed: "failed";
    readonly Expired: "expired";
    readonly Chargeback: "chargeback";
};
export type TransactionStatus = typeof TransactionStatus[keyof typeof TransactionStatus];
/**
 *
 * @export
 * @interface TransactionSteamInfo
 */
export interface TransactionSteamInfo {
    /**
     *
     * @type {TransactionSteamWalletInfo}
     * @memberof TransactionSteamInfo
     */
    'walletInfo': TransactionSteamWalletInfo;
    /**
     * Steam User ID
     * @type {string}
     * @memberof TransactionSteamInfo
     */
    'steamId': string;
    /**
     * Steam Order ID
     * @type {string}
     * @memberof TransactionSteamInfo
     */
    'orderId': string;
    /**
     * Empty
     * @type {string}
     * @memberof TransactionSteamInfo
     */
    'steamUrl': string;
    /**
     * Steam Transaction ID, NOT the same as VRChat TransactionID
     * @type {string}
     * @memberof TransactionSteamInfo
     */
    'transId': string;
}
/**
 *
 * @export
 * @interface TransactionSteamWalletInfo
 */
export interface TransactionSteamWalletInfo {
    /**
     *
     * @type {string}
     * @memberof TransactionSteamWalletInfo
     */
    'state': string;
    /**
     *
     * @type {string}
     * @memberof TransactionSteamWalletInfo
     */
    'country': string;
    /**
     *
     * @type {string}
     * @memberof TransactionSteamWalletInfo
     */
    'currency': string;
    /**
     *
     * @type {string}
     * @memberof TransactionSteamWalletInfo
     */
    'status': string;
}
/**
 *
 * @export
 * @interface TwoFactorAuthCode
 */
export interface TwoFactorAuthCode {
    /**
     *
     * @type {string}
     * @memberof TwoFactorAuthCode
     */
    'code': string;
}
/**
 *
 * @export
 * @interface UnityPackage
 */
export interface UnityPackage {
    /**
     *
     * @type {string}
     * @memberof UnityPackage
     */
    'assetUrl'?: string;
    /**
     *
     * @type {object}
     * @memberof UnityPackage
     */
    'assetUrlObject'?: object;
    /**
     *
     * @type {number}
     * @memberof UnityPackage
     */
    'assetVersion': number;
    /**
     *
     * @type {string}
     * @memberof UnityPackage
     */
    'created_at'?: string;
    /**
     *
     * @type {string}
     * @memberof UnityPackage
     */
    'id': string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof UnityPackage
     */
    'platform': string;
    /**
     *
     * @type {string}
     * @memberof UnityPackage
     */
    'pluginUrl'?: string;
    /**
     *
     * @type {object}
     * @memberof UnityPackage
     */
    'pluginUrlObject'?: object;
    /**
     *
     * @type {number}
     * @memberof UnityPackage
     */
    'unitySortNumber'?: number;
    /**
     *
     * @type {string}
     * @memberof UnityPackage
     */
    'unityVersion': string;
}
/**
 *
 * @export
 * @interface UpdateAvatarRequest
 */
export interface UpdateAvatarRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'assetUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'description'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateAvatarRequest
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'imageUrl'?: string;
    /**
     *
     * @type {ReleaseStatus}
     * @memberof UpdateAvatarRequest
     */
    'releaseStatus'?: ReleaseStatus;
    /**
     *
     * @type {number}
     * @memberof UpdateAvatarRequest
     */
    'version'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateAvatarRequest
     */
    'unityPackageUrl'?: string;
}
/**
 *
 * @export
 * @interface UpdateFavoriteGroupRequest
 */
export interface UpdateFavoriteGroupRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateFavoriteGroupRequest
     */
    'displayName'?: string;
    /**
     *
     * @type {FavoriteGroupVisibility}
     * @memberof UpdateFavoriteGroupRequest
     */
    'visibility'?: FavoriteGroupVisibility;
    /**
     * Tags on FavoriteGroups are believed to do nothing.
     * @type {Array<string>}
     * @memberof UpdateFavoriteGroupRequest
     */
    'tags'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateGroupGalleryRequest
 */
export interface UpdateGroupGalleryRequest {
    /**
     * Name of the gallery.
     * @type {string}
     * @memberof UpdateGroupGalleryRequest
     */
    'name'?: string;
    /**
     * Description of the gallery.
     * @type {string}
     * @memberof UpdateGroupGalleryRequest
     */
    'description'?: string;
    /**
     * Whether the gallery is members only.
     * @type {boolean}
     * @memberof UpdateGroupGalleryRequest
     */
    'membersOnly'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupGalleryRequest
     */
    'roleIdsToView'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupGalleryRequest
     */
    'roleIdsToSubmit'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupGalleryRequest
     */
    'roleIdsToAutoApprove'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupGalleryRequest
     */
    'roleIdsToManage'?: Array<string> | null;
}
/**
 *
 * @export
 * @interface UpdateGroupMemberRequest
 */
export interface UpdateGroupMemberRequest {
    /**
     *
     * @type {GroupUserVisibility}
     * @memberof UpdateGroupMemberRequest
     */
    'visibility'?: GroupUserVisibility;
    /**
     *
     * @type {boolean}
     * @memberof UpdateGroupMemberRequest
     */
    'isSubscribedToAnnouncements'?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdateGroupMemberRequest
     */
    'managerNotes'?: string;
}
/**
 *
 * @export
 * @interface UpdateGroupRequest
 */
export interface UpdateGroupRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'shortCode'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'description'?: string;
    /**
     *
     * @type {GroupJoinState}
     * @memberof UpdateGroupRequest
     */
    'joinState'?: GroupJoinState;
    /**
     *
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'iconId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'bannerId'?: string | null;
    /**
     * 3 letter language code
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'languages'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'links'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof UpdateGroupRequest
     */
    'rules'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupRequest
     */
    'tags'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateGroupRoleRequest
 */
export interface UpdateGroupRoleRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateGroupRoleRequest
     */
    'name'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateGroupRoleRequest
     */
    'description'?: string;
    /**
     *
     * @type {boolean}
     * @memberof UpdateGroupRoleRequest
     */
    'isSelfAssignable'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupRoleRequest
     */
    'permissions'?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof UpdateGroupRoleRequest
     */
    'order'?: number;
}
/**
 *
 * @export
 * @interface UpdateInviteMessageRequest
 */
export interface UpdateInviteMessageRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateInviteMessageRequest
     */
    'message': string;
}
/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'birthday'?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateUserRequest
     */
    'acceptedTOSVersion'?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {UserStatus}
     * @memberof UpdateUserRequest
     */
    'status'?: UserStatus;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'statusDescription'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'bio'?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    'bioLinks'?: Array<string>;
    /**
     * MUST be a valid VRChat /file/ url.
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'userIcon'?: string;
}
/**
 *
 * @export
 * @interface UpdateWorldRequest
 */
export interface UpdateWorldRequest {
    /**
     *
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'assetUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'assetVersion'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'authorId'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'authorName'?: string;
    /**
     *
     * @type {number}
     * @memberof UpdateWorldRequest
     */
    'capacity'?: number;
    /**
     *
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'description'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'imageUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'name'?: string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'platform'?: string;
    /**
     *
     * @type {ReleaseStatus}
     * @memberof UpdateWorldRequest
     */
    'releaseStatus'?: ReleaseStatus;
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateWorldRequest
     */
    'tags'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'unityPackageUrl'?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateWorldRequest
     */
    'unityVersion'?: string;
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
    /**
     *
     * @type {boolean}
     * @memberof User
     */
    'allowAvatarCopying': boolean;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'bio': string;
    /**
     *
     * @type {Array<string>}
     * @memberof User
     */
    'bioLinks': Array<string>;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof User
     */
    'currentAvatarImageUrl': string;
    /**
     * When profilePicOverride is not empty, use it instead.
     * @type {string}
     * @memberof User
     */
    'currentAvatarThumbnailImageUrl': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'date_joined': string;
    /**
     *
     * @type {DeveloperType}
     * @memberof User
     */
    'developerType': DeveloperType;
    /**
     * A users visual display name. This is what shows up in-game, and can different from their `username`. Changing display name is restricted to a cooldown period.
     * @type {string}
     * @memberof User
     */
    'displayName': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'friendKey': string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'friendRequestStatus'?: string;
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * InstanceID can be \"offline\" on User profiles if you are not friends with that user and \"private\" if you are friends and user is in private instance.
     * @type {string}
     * @memberof User
     */
    'instanceId'?: string;
    /**
     * Either their `friendKey`, or empty string if you are not friends. Unknown usage.
     * @type {boolean}
     * @memberof User
     */
    'isFriend': boolean;
    /**
     * Either a date-time or empty string.
     * @type {string}
     * @memberof User
     */
    'last_activity': string;
    /**
     * Either a date-time or empty string.
     * @type {string}
     * @memberof User
     */
    'last_login': string;
    /**
     * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
     * @type {string}
     * @memberof User
     */
    'last_platform': string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof User
     */
    'location'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'note'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'profilePicOverride': string;
    /**
     *
     * @type {UserState}
     * @memberof User
     */
    'state': UserState;
    /**
     *
     * @type {UserStatus}
     * @memberof User
     */
    'status': UserStatus;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'statusDescription': string;
    /**
     *
     * @type {Array<string>}
     * @memberof User
     */
    'tags': Array<string>;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'travelingToInstance'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'travelingToLocation'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'travelingToWorld'?: string;
    /**
     *
     * @type {string}
     * @memberof User
     */
    'userIcon': string;
    /**
     * -| A users unique name, used during login. This is different from `displayName` which is what shows up in-game. A users `username` can never be changed.\' **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @type {string}
     * @memberof User
     * @deprecated
     */
    'username'?: string;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof User
     */
    'worldId'?: string;
}
/**
 * Status object representing if a queried user by username or userId exists or not. This model is primarily used by the `/auth/exists` endpoint, which in turn is used during registration. Please see the documentation on that endpoint for more information on usage.
 * @export
 * @interface UserExists
 */
export interface UserExists {
    /**
     * Status if a user exist with that username or userId.
     * @type {boolean}
     * @memberof UserExists
     */
    'userExists': boolean;
}
/**
 * * \"online\" User is online in VRChat * \"active\" User is online, but not in VRChat * \"offline\" User is offline  Always offline when returned through `getCurrentUser` (/auth/user).
 * @export
 * @enum {string}
 */
export declare const UserState: {
    readonly Offline: "offline";
    readonly Active: "active";
    readonly Online: "online";
};
export type UserState = typeof UserState[keyof typeof UserState];
/**
 * Defines the User\'s current status, for example \"ask me\", \"join me\" or \"offline. This status is a combined indicator of their online activity and privacy preference.
 * @export
 * @enum {string}
 */
export declare const UserStatus: {
    readonly Active: "active";
    readonly JoinMe: "join me";
    readonly AskMe: "ask me";
    readonly Busy: "busy";
    readonly Offline: "offline";
};
export type UserStatus = typeof UserStatus[keyof typeof UserStatus];
/**
 *
 * @export
 * @interface UserSubscription
 */
export interface UserSubscription {
    /**
     *
     * @type {string}
     * @memberof UserSubscription
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof UserSubscription
     */
    'transactionId': string;
    /**
     * Which \"Store\" it came from. Right now only Stores are \"Steam\" and \"Admin\".
     * @type {string}
     * @memberof UserSubscription
     */
    'store': string;
    /**
     *
     * @type {string}
     * @memberof UserSubscription
     */
    'steamItemId'?: string;
    /**
     *
     * @type {number}
     * @memberof UserSubscription
     */
    'amount': number;
    /**
     *
     * @type {string}
     * @memberof UserSubscription
     */
    'description': string;
    /**
     *
     * @type {SubscriptionPeriod}
     * @memberof UserSubscription
     */
    'period': SubscriptionPeriod;
    /**
     *
     * @type {number}
     * @memberof UserSubscription
     */
    'tier': number;
    /**
     *
     * @type {boolean}
     * @memberof UserSubscription
     */
    'active': boolean;
    /**
     *
     * @type {TransactionStatus}
     * @memberof UserSubscription
     */
    'status': TransactionStatus;
    /**
     *
     * @type {string}
     * @memberof UserSubscription
     */
    'expires': string;
    /**
     *
     * @type {string}
     * @memberof UserSubscription
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof UserSubscription
     */
    'updated_at': string;
    /**
     *
     * @type {Array<string>}
     * @memberof UserSubscription
     */
    'licenseGroups': Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof UserSubscription
     */
    'isGift': boolean;
}
/**
 *
 * @export
 * @interface Verify2FAResult
 */
export interface Verify2FAResult {
    /**
     *
     * @type {boolean}
     * @memberof Verify2FAResult
     */
    'verified': boolean;
}
/**
 *
 * @export
 * @interface VerifyAuthTokenResult
 */
export interface VerifyAuthTokenResult {
    /**
     *
     * @type {boolean}
     * @memberof VerifyAuthTokenResult
     */
    'ok': boolean;
    /**
     *
     * @type {string}
     * @memberof VerifyAuthTokenResult
     */
    'token': string;
}
/**
 *
 * @export
 * @interface World
 */
export interface World {
    /**
     * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
     * @type {string}
     * @memberof World
     */
    'authorId': string;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'authorName': string;
    /**
     *
     * @type {number}
     * @memberof World
     */
    'capacity': number;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'description': string;
    /**
     *
     * @type {number}
     * @memberof World
     */
    'favorites'?: number;
    /**
     *
     * @type {boolean}
     * @memberof World
     */
    'featured': boolean;
    /**
     *
     * @type {number}
     * @memberof World
     */
    'heat': number;
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof World
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'imageUrl': string;
    /**
     * Will always be an empty list when unauthenticated.
     * @type {Array<Array<any>>}
     * @memberof World
     */
    'instances'?: Array<Array<any>>;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'labsPublicationDate': string;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'name': string;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'namespace': string;
    /**
     * Will always be `0` when unauthenticated.
     * @type {number}
     * @memberof World
     */
    'occupants'?: number;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'organization': string;
    /**
     *
     * @type {number}
     * @memberof World
     */
    'popularity': number;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'previewYoutubeId'?: string | null;
    /**
     * Will always be `0` when unauthenticated.
     * @type {number}
     * @memberof World
     */
    'privateOccupants'?: number;
    /**
     * Will always be `0` when unauthenticated.
     * @type {number}
     * @memberof World
     */
    'publicOccupants'?: number;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'publicationDate': string;
    /**
     *
     * @type {ReleaseStatus}
     * @memberof World
     */
    'releaseStatus': ReleaseStatus;
    /**
     *
     * @type {Array<string>}
     * @memberof World
     */
    'tags': Array<string>;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'thumbnailImageUrl': string;
    /**
     * Empty if unauthenticated.
     * @type {Array<UnityPackage>}
     * @memberof World
     */
    'unityPackages': Array<UnityPackage>;
    /**
     *
     * @type {string}
     * @memberof World
     */
    'updated_at': string;
    /**
     *
     * @type {number}
     * @memberof World
     */
    'version': number;
    /**
     *
     * @type {number}
     * @memberof World
     */
    'visits': number;
}
/**
 *
 * @export
 * @interface WorldMetadata
 */
export interface WorldMetadata {
    /**
     * WorldID be \"offline\" on User profiles if you are not friends with that user.
     * @type {string}
     * @memberof WorldMetadata
     */
    'id': string;
    /**
     *
     * @type {object}
     * @memberof WorldMetadata
     */
    'metadata': object;
}
/**
 *
 * @export
 * @interface WorldPublishStatus
 */
export interface WorldPublishStatus {
    /**
     *
     * @type {boolean}
     * @memberof WorldPublishStatus
     */
    'canPubilsh': boolean;
}
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export declare const AuthenticationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
     * @summary Check User Exists
     * @param {string} [email] Filter by email.
     * @param {string} [displayName] Filter by displayName.
     * @param {string} [userId] Filter by UserID.
     * @param {string} [excludeUserId] Exclude by UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserExists: (email?: string, displayName?: string, userId?: string, excludeUserId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @summary Delete User
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @summary Login and/or Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Invalidates the login session.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verify2FA: (twoFactorAuthCode?: TwoFactorAuthCode, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Verify whether the currently provided Auth Token is valid.
     * @summary Verify Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyAuthToken: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code with Recovery code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyRecoveryCode: (twoFactorAuthCode?: TwoFactorAuthCode, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export declare const AuthenticationApiFp: (configuration?: Configuration) => {
    /**
     * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
     * @summary Check User Exists
     * @param {string} [email] Filter by email.
     * @param {string} [displayName] Filter by displayName.
     * @param {string} [userId] Filter by UserID.
     * @param {string} [excludeUserId] Exclude by UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserExists(email?: string, displayName?: string, userId?: string, excludeUserId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExists>>;
    /**
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @summary Delete User
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>>;
    /**
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @summary Login and/or Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>>;
    /**
     * Invalidates the login session.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verify2FA(twoFactorAuthCode?: TwoFactorAuthCode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verify2FAResult>>;
    /**
     * Verify whether the currently provided Auth Token is valid.
     * @summary Verify Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyAuthToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyAuthTokenResult>>;
    /**
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code with Recovery code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyRecoveryCode(twoFactorAuthCode?: TwoFactorAuthCode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Verify2FAResult>>;
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
export declare const AuthenticationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
     * @summary Check User Exists
     * @param {string} [email] Filter by email.
     * @param {string} [displayName] Filter by displayName.
     * @param {string} [userId] Filter by UserID.
     * @param {string} [excludeUserId] Exclude by UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUserExists(email?: string, displayName?: string, userId?: string, excludeUserId?: string, options?: any): AxiosPromise<UserExists>;
    /**
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @summary Delete User
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userId: string, options?: any): AxiosPromise<CurrentUser>;
    /**
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @summary Login and/or Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(options?: any): AxiosPromise<CurrentUser>;
    /**
     * Invalidates the login session.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<Success>;
    /**
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verify2FA(twoFactorAuthCode?: TwoFactorAuthCode, options?: any): AxiosPromise<Verify2FAResult>;
    /**
     * Verify whether the currently provided Auth Token is valid.
     * @summary Verify Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyAuthToken(options?: any): AxiosPromise<VerifyAuthTokenResult>;
    /**
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code with Recovery code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyRecoveryCode(twoFactorAuthCode?: TwoFactorAuthCode, options?: any): AxiosPromise<Verify2FAResult>;
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export declare class AuthenticationApi extends BaseAPI {
    /**
     * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
     * @summary Check User Exists
     * @param {string} [email] Filter by email.
     * @param {string} [displayName] Filter by displayName.
     * @param {string} [userId] Filter by UserID.
     * @param {string} [excludeUserId] Exclude by UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    checkUserExists(email?: string, displayName?: string, userId?: string, excludeUserId?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UserExists, any>>;
    /**
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @summary Delete User
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    deleteUser(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CurrentUser, any>>;
    /**
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    > base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @summary Login and/or Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getCurrentUser(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CurrentUser, any>>;
    /**
     * Invalidates the login session.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    logout(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    verify2FA(twoFactorAuthCode?: TwoFactorAuthCode, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Verify2FAResult, any>>;
    /**
     * Verify whether the currently provided Auth Token is valid.
     * @summary Verify Auth Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    verifyAuthToken(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<VerifyAuthTokenResult, any>>;
    /**
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @summary Verify 2FA code with Recovery code
     * @param {TwoFactorAuthCode} [twoFactorAuthCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    verifyRecoveryCode(twoFactorAuthCode?: TwoFactorAuthCode, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Verify2FAResult, any>>;
}
/**
 * AvatarsApi - axios parameter creator
 * @export
 */
export declare const AvatarsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
     * @summary Create Avatar
     * @param {CreateAvatarRequest} [createAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAvatar: (createAvatarRequest?: CreateAvatarRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
     * @summary Delete Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar: (avatarId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get information about a specific Avatar.
     * @summary Get Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatar: (avatarId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Search and list favorited avatars by query filters.
     * @summary List Favorited Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritedAvatars: (featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the current avatar for the user. This will return an error for any other user than the one logged in.
     * @summary Get Own Avatar
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnAvatar: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
     * @summary Search Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAvatars: (featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Switches into that avatar.
     * @summary Select Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selectAvatar: (avatarId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Switches into that avatar as your fallback avatar.
     * @summary Select Fallback Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selectFallbackAvatar: (avatarId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update information about a specific avatar.
     * @summary Update Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {UpdateAvatarRequest} [updateAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAvatar: (avatarId: string, updateAvatarRequest?: UpdateAvatarRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * AvatarsApi - functional programming interface
 * @export
 */
export declare const AvatarsApiFp: (configuration?: Configuration) => {
    /**
     * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
     * @summary Create Avatar
     * @param {CreateAvatarRequest} [createAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAvatar(createAvatarRequest?: CreateAvatarRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>>;
    /**
     * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
     * @summary Delete Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>>;
    /**
     * Get information about a specific Avatar.
     * @summary Get Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>>;
    /**
     * Search and list favorited avatars by query filters.
     * @summary List Favorited Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritedAvatars(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Avatar>>>;
    /**
     * Get the current avatar for the user. This will return an error for any other user than the one logged in.
     * @summary Get Own Avatar
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnAvatar(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>>;
    /**
     * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
     * @summary Search Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAvatars(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Avatar>>>;
    /**
     * Switches into that avatar.
     * @summary Select Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selectAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>>;
    /**
     * Switches into that avatar as your fallback avatar.
     * @summary Select Fallback Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selectFallbackAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>>;
    /**
     * Update information about a specific avatar.
     * @summary Update Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {UpdateAvatarRequest} [updateAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAvatar(avatarId: string, updateAvatarRequest?: UpdateAvatarRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Avatar>>;
};
/**
 * AvatarsApi - factory interface
 * @export
 */
export declare const AvatarsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
     * @summary Create Avatar
     * @param {CreateAvatarRequest} [createAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAvatar(createAvatarRequest?: CreateAvatarRequest, options?: any): AxiosPromise<Avatar>;
    /**
     * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
     * @summary Delete Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAvatar(avatarId: string, options?: any): AxiosPromise<Avatar>;
    /**
     * Get information about a specific Avatar.
     * @summary Get Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvatar(avatarId: string, options?: any): AxiosPromise<Avatar>;
    /**
     * Search and list favorited avatars by query filters.
     * @summary List Favorited Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritedAvatars(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: any): AxiosPromise<Array<Avatar>>;
    /**
     * Get the current avatar for the user. This will return an error for any other user than the one logged in.
     * @summary Get Own Avatar
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnAvatar(userId: string, options?: any): AxiosPromise<Avatar>;
    /**
     * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
     * @summary Search Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAvatars(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: any): AxiosPromise<Array<Avatar>>;
    /**
     * Switches into that avatar.
     * @summary Select Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selectAvatar(avatarId: string, options?: any): AxiosPromise<CurrentUser>;
    /**
     * Switches into that avatar as your fallback avatar.
     * @summary Select Fallback Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    selectFallbackAvatar(avatarId: string, options?: any): AxiosPromise<CurrentUser>;
    /**
     * Update information about a specific avatar.
     * @summary Update Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {UpdateAvatarRequest} [updateAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAvatar(avatarId: string, updateAvatarRequest?: UpdateAvatarRequest, options?: any): AxiosPromise<Avatar>;
};
/**
 * AvatarsApi - object-oriented interface
 * @export
 * @class AvatarsApi
 * @extends {BaseAPI}
 */
export declare class AvatarsApi extends BaseAPI {
    /**
     * Create an avatar. It\'s possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
     * @summary Create Avatar
     * @param {CreateAvatarRequest} [createAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    createAvatar(createAvatarRequest?: CreateAvatarRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Avatar, any>>;
    /**
     * Delete an avatar. Notice an avatar is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The AvatarID is permanently reserved.
     * @summary Delete Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    deleteAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Avatar, any>>;
    /**
     * Get information about a specific Avatar.
     * @summary Get Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    getAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Avatar, any>>;
    /**
     * Search and list favorited avatars by query filters.
     * @summary List Favorited Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    getFavoritedAvatars(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Avatar[], any>>;
    /**
     * Get the current avatar for the user. This will return an error for any other user than the one logged in.
     * @summary Get Own Avatar
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    getOwnAvatar(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Avatar, any>>;
    /**
     * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
     * @summary Search Avatars
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own avatars.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    searchAvatars(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Avatar[], any>>;
    /**
     * Switches into that avatar.
     * @summary Select Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    selectAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CurrentUser, any>>;
    /**
     * Switches into that avatar as your fallback avatar.
     * @summary Select Fallback Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    selectFallbackAvatar(avatarId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CurrentUser, any>>;
    /**
     * Update information about a specific avatar.
     * @summary Update Avatar
     * @param {string} avatarId Must be a valid avatar ID.
     * @param {UpdateAvatarRequest} [updateAvatarRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvatarsApi
     */
    updateAvatar(avatarId: string, updateAvatarRequest?: UpdateAvatarRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Avatar, any>>;
}
/**
 * EconomyApi - axios parameter creator
 * @export
 */
export declare const EconomyApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get a list of all current user subscriptions.
     * @summary Get Current Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentSubscriptions: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a single License Group by given ID.
     * @summary Get License Group
     * @param {string} licenseGroupId Must be a valid license group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseGroup: (licenseGroupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
     * @summary Get Steam Transaction
     * @param {string} transactionId Must be a valid transaction ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getSteamTransaction: (transactionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get all own Steam transactions.
     * @summary List Steam Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSteamTransactions: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
     * @summary List Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * EconomyApi - functional programming interface
 * @export
 */
export declare const EconomyApiFp: (configuration?: Configuration) => {
    /**
     * Get a list of all current user subscriptions.
     * @summary Get Current Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentSubscriptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSubscription>>>;
    /**
     * Get a single License Group by given ID.
     * @summary Get License Group
     * @param {string} licenseGroupId Must be a valid license group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseGroup(licenseGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseGroup>>;
    /**
     * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
     * @summary Get Steam Transaction
     * @param {string} transactionId Must be a valid transaction ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getSteamTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>>;
    /**
     * Get all own Steam transactions.
     * @summary List Steam Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSteamTransactions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>>;
    /**
     * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
     * @summary List Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Subscription>>>;
};
/**
 * EconomyApi - factory interface
 * @export
 */
export declare const EconomyApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get a list of all current user subscriptions.
     * @summary Get Current Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentSubscriptions(options?: any): AxiosPromise<Array<UserSubscription>>;
    /**
     * Get a single License Group by given ID.
     * @summary Get License Group
     * @param {string} licenseGroupId Must be a valid license group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseGroup(licenseGroupId: string, options?: any): AxiosPromise<LicenseGroup>;
    /**
     * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
     * @summary Get Steam Transaction
     * @param {string} transactionId Must be a valid transaction ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getSteamTransaction(transactionId: string, options?: any): AxiosPromise<Transaction>;
    /**
     * Get all own Steam transactions.
     * @summary List Steam Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSteamTransactions(options?: any): AxiosPromise<Array<Transaction>>;
    /**
     * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
     * @summary List Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubscriptions(options?: any): AxiosPromise<Array<Subscription>>;
};
/**
 * EconomyApi - object-oriented interface
 * @export
 * @class EconomyApi
 * @extends {BaseAPI}
 */
export declare class EconomyApi extends BaseAPI {
    /**
     * Get a list of all current user subscriptions.
     * @summary Get Current Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    getCurrentSubscriptions(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<UserSubscription[], any>>;
    /**
     * Get a single License Group by given ID.
     * @summary Get License Group
     * @param {string} licenseGroupId Must be a valid license group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    getLicenseGroup(licenseGroupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LicenseGroup, any>>;
    /**
     * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
     * @summary Get Steam Transaction
     * @param {string} transactionId Must be a valid transaction ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    getSteamTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Transaction, any>>;
    /**
     * Get all own Steam transactions.
     * @summary List Steam Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    getSteamTransactions(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Transaction[], any>>;
    /**
     * List all existing Subscriptions. For example, \"vrchatplus-monthly\" and \"vrchatplus-yearly\".
     * @summary List Subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EconomyApi
     */
    getSubscriptions(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Subscription[], any>>;
}
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
export declare const FavoritesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     * @summary Add Favorite
     * @param {AddFavoriteRequest} [addFavoriteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFavorite: (addFavoriteRequest?: AddFavoriteRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Clear ALL contents of a specific favorite group.
     * @summary Clear Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearFavoriteGroup: (favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Return information about a specific Favorite.
     * @summary Show Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavorite: (favoriteId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetch information about a specific favorite group.
     * @summary Show Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoriteGroup: (favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
     * @summary List Favorite Groups
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoriteGroups: (n?: number, offset?: number, ownerId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of favorites.
     * @summary List Favorites
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [type] The type of favorites to return, FavoriteType.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavorites: (n?: number, offset?: number, type?: string, tag?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Remove a favorite from your favorites list.
     * @summary Remove Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFavorite: (favoriteId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update information about a specific favorite group.
     * @summary Update Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFavoriteGroup: (favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, updateFavoriteGroupRequest?: UpdateFavoriteGroupRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FavoritesApi - functional programming interface
 * @export
 */
export declare const FavoritesApiFp: (configuration?: Configuration) => {
    /**
     * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     * @summary Add Favorite
     * @param {AddFavoriteRequest} [addFavoriteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFavorite(addFavoriteRequest?: AddFavoriteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Favorite>>;
    /**
     * Clear ALL contents of a specific favorite group.
     * @summary Clear Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Return information about a specific Favorite.
     * @summary Show Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavorite(favoriteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Favorite>>;
    /**
     * Fetch information about a specific favorite group.
     * @summary Show Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FavoriteGroup>>;
    /**
     * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
     * @summary List Favorite Groups
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoriteGroups(n?: number, offset?: number, ownerId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FavoriteGroup>>>;
    /**
     * Returns a list of favorites.
     * @summary List Favorites
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [type] The type of favorites to return, FavoriteType.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavorites(n?: number, offset?: number, type?: string, tag?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Favorite>>>;
    /**
     * Remove a favorite from your favorites list.
     * @summary Remove Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFavorite(favoriteId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Update information about a specific favorite group.
     * @summary Update Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, updateFavoriteGroupRequest?: UpdateFavoriteGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FavoritesApi - factory interface
 * @export
 */
export declare const FavoritesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     * @summary Add Favorite
     * @param {AddFavoriteRequest} [addFavoriteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFavorite(addFavoriteRequest?: AddFavoriteRequest, options?: any): AxiosPromise<Favorite>;
    /**
     * Clear ALL contents of a specific favorite group.
     * @summary Clear Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: any): AxiosPromise<Success>;
    /**
     * Return information about a specific Favorite.
     * @summary Show Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavorite(favoriteId: string, options?: any): AxiosPromise<Favorite>;
    /**
     * Fetch information about a specific favorite group.
     * @summary Show Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: any): AxiosPromise<FavoriteGroup>;
    /**
     * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
     * @summary List Favorite Groups
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoriteGroups(n?: number, offset?: number, ownerId?: string, options?: any): AxiosPromise<Array<FavoriteGroup>>;
    /**
     * Returns a list of favorites.
     * @summary List Favorites
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [type] The type of favorites to return, FavoriteType.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavorites(n?: number, offset?: number, type?: string, tag?: string, options?: any): AxiosPromise<Array<Favorite>>;
    /**
     * Remove a favorite from your favorites list.
     * @summary Remove Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeFavorite(favoriteId: string, options?: any): AxiosPromise<Success>;
    /**
     * Update information about a specific favorite group.
     * @summary Update Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, updateFavoriteGroupRequest?: UpdateFavoriteGroupRequest, options?: any): AxiosPromise<void>;
};
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
export declare class FavoritesApi extends BaseAPI {
    /**
     * Add a new favorite.  Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.  You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     * @summary Add Favorite
     * @param {AddFavoriteRequest} [addFavoriteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addFavorite(addFavoriteRequest?: AddFavoriteRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Favorite, any>>;
    /**
     * Clear ALL contents of a specific favorite group.
     * @summary Clear Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    clearFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Return information about a specific Favorite.
     * @summary Show Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getFavorite(favoriteId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Favorite, any>>;
    /**
     * Fetch information about a specific favorite group.
     * @summary Show Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FavoriteGroup, any>>;
    /**
     * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
     * @summary List Favorite Groups
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [ownerId] The owner of whoms favorite groups to return. Must be a UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getFavoriteGroups(n?: number, offset?: number, ownerId?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FavoriteGroup[], any>>;
    /**
     * Returns a list of favorites.
     * @summary List Favorites
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [type] The type of favorites to return, FavoriteType.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getFavorites(n?: number, offset?: number, type?: string, tag?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Favorite[], any>>;
    /**
     * Remove a favorite from your favorites list.
     * @summary Remove Favorite
     * @param {string} favoriteId Must be a valid favorite ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    removeFavorite(favoriteId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Update information about a specific favorite group.
     * @summary Update Favorite Group
     * @param {'world' | 'friend' | 'avatar'} favoriteGroupType The type of group to fetch, must be a valid FavoriteType.
     * @param {string} favoriteGroupName The name of the group to fetch, must be a name of a FavoriteGroup.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateFavoriteGroupRequest} [updateFavoriteGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    updateFavoriteGroup(favoriteGroupType: 'world' | 'friend' | 'avatar', favoriteGroupName: string, userId: string, updateFavoriteGroupRequest?: UpdateFavoriteGroupRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
export declare const FilesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Creates a new File object
     * @summary Create File
     * @param {CreateFileRequest} [createFileRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile: (createFileRequest?: CreateFileRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     * @summary Create File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {CreateFileVersionRequest} [createFileVersionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileVersion: (fileId: string, createFileVersionRequest?: CreateFileVersionRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes a File object.
     * @summary Delete File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: (fileId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete a specific version of a file. You can only delete the latest version.
     * @summary Delete File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileVersion: (fileId: string, versionId: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     * @summary Download File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFileVersion: (fileId: string, versionId: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     * @summary Finish FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finishFileDataUpload: (fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', finishFileDataUploadRequest?: FinishFileDataUploadRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
     * @summary Show File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile: (fileId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     * @summary Check FileData Upload Status
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileDataUploadStatus: (fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of files
     * @summary List Files
     * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
     * @param {string} [userId] UserID, will always generate a 500 permission error.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles: (tag?: string, userId?: string, n?: number, offset?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @summary Start FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startFileDataUpload: (fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', partNumber?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FilesApi - functional programming interface
 * @export
 */
export declare const FilesApiFp: (configuration?: Configuration) => {
    /**
     * Creates a new File object
     * @summary Create File
     * @param {CreateFileRequest} [createFileRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(createFileRequest?: CreateFileRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     * @summary Create File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {CreateFileVersionRequest} [createFileVersionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileVersion(fileId: string, createFileVersionRequest?: CreateFileVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * Deletes a File object.
     * @summary Delete File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Delete a specific version of a file. You can only delete the latest version.
     * @summary Delete File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileVersion(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     * @summary Download File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFileVersion(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     * @summary Finish FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finishFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', finishFileDataUploadRequest?: FinishFileDataUploadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
     * @summary Show File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>>;
    /**
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     * @summary Check FileData Upload Status
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileDataUploadStatus(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileVersionUploadStatus>>;
    /**
     * Returns a list of files
     * @summary List Files
     * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
     * @param {string} [userId] UserID, will always generate a 500 permission error.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles(tag?: string, userId?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>>;
    /**
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @summary Start FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', partNumber?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadURL>>;
};
/**
 * FilesApi - factory interface
 * @export
 */
export declare const FilesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Creates a new File object
     * @summary Create File
     * @param {CreateFileRequest} [createFileRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFile(createFileRequest?: CreateFileRequest, options?: any): AxiosPromise<any>;
    /**
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     * @summary Create File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {CreateFileVersionRequest} [createFileVersionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileVersion(fileId: string, createFileVersionRequest?: CreateFileVersionRequest, options?: any): AxiosPromise<any>;
    /**
     * Deletes a File object.
     * @summary Delete File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(fileId: string, options?: any): AxiosPromise<Success>;
    /**
     * Delete a specific version of a file. You can only delete the latest version.
     * @summary Delete File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFileVersion(fileId: string, versionId: number, options?: any): AxiosPromise<any>;
    /**
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     * @summary Download File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFileVersion(fileId: string, versionId: number, options?: any): AxiosPromise<void>;
    /**
     * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     * @summary Finish FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    finishFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', finishFileDataUploadRequest?: FinishFileDataUploadRequest, options?: any): AxiosPromise<any>;
    /**
     * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
     * @summary Show File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFile(fileId: string, options?: any): AxiosPromise<any>;
    /**
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     * @summary Check FileData Upload Status
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileDataUploadStatus(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', options?: any): AxiosPromise<FileVersionUploadStatus>;
    /**
     * Returns a list of files
     * @summary List Files
     * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
     * @param {string} [userId] UserID, will always generate a 500 permission error.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFiles(tag?: string, userId?: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<any>>;
    /**
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @summary Start FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', partNumber?: number, options?: any): AxiosPromise<FileUploadURL>;
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export declare class FilesApi extends BaseAPI {
    /**
     * Creates a new File object
     * @summary Create File
     * @param {CreateFileRequest} [createFileRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    createFile(createFileRequest?: CreateFileRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<any, any>>;
    /**
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     * @summary Create File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {CreateFileVersionRequest} [createFileVersionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    createFileVersion(fileId: string, createFileVersionRequest?: CreateFileVersionRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<any, any>>;
    /**
     * Deletes a File object.
     * @summary Delete File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFile(fileId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Delete a specific version of a file. You can only delete the latest version.
     * @summary Delete File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFileVersion(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<any, any>>;
    /**
     * Downloads the file with the provided version number.  **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.  **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     * @summary Download File Version
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    downloadFileVersion(fileId: string, versionId: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Finish an upload of a FileData. This will mark it as \"complete\". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     * @summary Finish FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {FinishFileDataUploadRequest} [finishFileDataUploadRequest] Please see documentation on ETag\&#39;s: [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)  ETag\&#39;s should NOT be present when uploading a &#x60;signature&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    finishFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', finishFileDataUploadRequest?: FinishFileDataUploadRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<any, any>>;
    /**
     * Shows general information about the \"File\" object. Each File can have several \"Version\"\'s, and each Version can have multiple real files or \"Data\" blobs.
     * @summary Show File
     * @param {string} fileId Must be a valid file ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFile(fileId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<any, any>>;
    /**
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     * @summary Check FileData Upload Status
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFileDataUploadStatus(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FileVersionUploadStatus, any>>;
    /**
     * Returns a list of files
     * @summary List Files
     * @param {string} [tag] Tag, for example \&quot;icon\&quot; or \&quot;gallery\&quot;, not included by default.
     * @param {string} [userId] UserID, will always generate a 500 permission error.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFiles(tag?: string, userId?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<any[], any>>;
    /**
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS\'s REST documentation on \"PUT Object to S3\" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.  **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     * @summary Start FileData Upload
     * @param {string} fileId Must be a valid file ID.
     * @param {number} versionId Version ID of the asset.
     * @param {'file' | 'signature' | 'delta'} fileType Type of file.
     * @param {number} [partNumber] The part number to start uploading. If not provided, the first part will be started.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    startFileDataUpload(fileId: string, versionId: number, fileType: 'file' | 'signature' | 'delta', partNumber?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FileUploadURL, any>>;
}
/**
 * FriendsApi - axios parameter creator
 * @export
 */
export declare const FriendsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
     * @summary Delete Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFriendRequest: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Send a friend request to another user.
     * @summary Send Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    friend: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
     * @summary Check Friend Status
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriendStatus: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List information about friends.
     * @summary List Friends
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {number} [n] The number of objects to return.
     * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriends: (offset?: number, n?: number, offline?: boolean, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Unfriend a user by ID.
     * @summary Unfriend
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfriend: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FriendsApi - functional programming interface
 * @export
 */
export declare const FriendsApiFp: (configuration?: Configuration) => {
    /**
     * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
     * @summary Delete Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFriendRequest(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Send a friend request to another user.
     * @summary Send Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    friend(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>>;
    /**
     * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
     * @summary Check Friend Status
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriendStatus(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FriendStatus>>;
    /**
     * List information about friends.
     * @summary List Friends
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {number} [n] The number of objects to return.
     * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriends(offset?: number, n?: number, offline?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedUser>>>;
    /**
     * Unfriend a user by ID.
     * @summary Unfriend
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfriend(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
};
/**
 * FriendsApi - factory interface
 * @export
 */
export declare const FriendsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
     * @summary Delete Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFriendRequest(userId: string, options?: any): AxiosPromise<Success>;
    /**
     * Send a friend request to another user.
     * @summary Send Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    friend(userId: string, options?: any): AxiosPromise<Notification>;
    /**
     * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
     * @summary Check Friend Status
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriendStatus(userId: string, options?: any): AxiosPromise<FriendStatus>;
    /**
     * List information about friends.
     * @summary List Friends
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {number} [n] The number of objects to return.
     * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFriends(offset?: number, n?: number, offline?: boolean, options?: any): AxiosPromise<Array<LimitedUser>>;
    /**
     * Unfriend a user by ID.
     * @summary Unfriend
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfriend(userId: string, options?: any): AxiosPromise<Success>;
};
/**
 * FriendsApi - object-oriented interface
 * @export
 * @class FriendsApi
 * @extends {BaseAPI}
 */
export declare class FriendsApi extends BaseAPI {
    /**
     * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
     * @summary Delete Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    deleteFriendRequest(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Send a friend request to another user.
     * @summary Send Friend Request
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    friend(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Notification, any>>;
    /**
     * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
     * @summary Check Friend Status
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    getFriendStatus(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FriendStatus, any>>;
    /**
     * List information about friends.
     * @summary List Friends
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {number} [n] The number of objects to return.
     * @param {boolean} [offline] Returns *only* offline users if true, returns only online and active users if false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    getFriends(offset?: number, n?: number, offline?: boolean, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LimitedUser[], any>>;
    /**
     * Unfriend a user by ID.
     * @summary Unfriend
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    unfriend(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
}
/**
 * GroupsApi - axios parameter creator
 * @export
 */
export declare const GroupsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Adds an image to a Group gallery.
     * @summary Add Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {AddGroupGalleryImageRequest} [addGroupGalleryImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupGalleryImage: (groupId: string, groupGalleryId: string, addGroupGalleryImageRequest?: AddGroupGalleryImageRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Adds a Role to a Group Member
     * @summary Add Role to GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupMemberRole: (groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Bans a user from a Group.
     * @summary Ban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {BanGroupMemberRequest} [banGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    banGroupMember: (groupId: string, banGroupMemberRequest?: BanGroupMemberRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Cancels a request sent to join the group.
     * @summary Cancel Group Join Request
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelGroupRequest: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
     * @summary Create Group
     * @param {CreateGroupRequest} [createGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup: (createGroupRequest?: CreateGroupRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Creates an Announcement for a Group.
     * @summary Create Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupAnnouncementRequest} [createGroupAnnouncementRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupAnnouncement: (groupId: string, createGroupAnnouncementRequest?: CreateGroupAnnouncementRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Creates a gallery for a Group.
     * @summary Create Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupGalleryRequest} [createGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupGallery: (groupId: string, createGroupGalleryRequest?: CreateGroupGalleryRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Sends an invite to a user to join the group.
     * @summary Invite User to Group
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupInviteRequest} [createGroupInviteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupInvite: (groupId: string, createGroupInviteRequest?: CreateGroupInviteRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Create a Group role.
     * @summary Create GroupRole
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupRoleRequest} [createGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupRole: (groupId: string, createGroupRoleRequest?: CreateGroupRoleRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes a Group.
     * @summary Delete Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes the announcement for a Group.
     * @summary Delete Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupAnnouncement: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes a gallery for a Group.
     * @summary Delete Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupGallery: (groupId: string, groupGalleryId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes an image from a Group gallery.
     * @summary Delete Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupGalleryImage: (groupId: string, groupGalleryId: string, groupGalleryImageId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes an Group invite sent to a User
     * @summary Delete User Invite
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupInvite: (groupId: string, userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes a Group Role by ID and returns the remaining roles.
     * @summary Delete Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupRole: (groupId: string, groupRoleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a single Group by ID.
     * @summary Get Group by ID
     * @param {string} groupId Must be a valid group ID.
     * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup: (groupId: string, includeRoles?: boolean, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
     * @summary Get Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupAnnouncements: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of audit logs for a Group.
     * @summary Get Group Audit Logs
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [startDate] The start date of the search range.
     * @param {string} [endDate] The end date of the search range.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupAuditLogs: (groupId: string, n?: number, offset?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of banned users for a Group.
     * @summary Get Group Bans
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupBans: (groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of images for a Group gallery.
     * @summary Get Group Gallery Images
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupGalleryImages: (groupId: string, groupGalleryId: string, n?: number, offset?: number, approved?: boolean, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of members that have been invited to the Group.
     * @summary Get Group Invites Sent
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupInvites: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a LimitedGroup Member.
     * @summary Get Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMember: (groupId: string, userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
     * @summary List Group Members
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMembers: (groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a List of all possible/available permissions for a Group.
     * @summary List Group Permissions
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupPermissions: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of members that have requested to join the Group.
     * @summary Get Group Join Requests
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupRequests: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a Group Role by ID.
     * @summary Get Group Roles
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupRoles: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Join a Group by ID and returns the joined Group.
     * @summary Join Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinGroup: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
     * @summary Kick Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    kickGroupMember: (groupId: string, userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Leave a group by ID.
     * @summary Leave Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGroup: (groupId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Removes a Role from a Group Member
     * @summary Remove Role from GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupMemberRole: (groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Responds to a Group Join Request with Accept/Deny
     * @summary Respond Group Join request
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {RespondGroupJoinRequest} [respondGroupJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondGroupJoinRequest: (groupId: string, userId: string, respondGroupJoinRequest?: RespondGroupJoinRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Unbans a user from a Group.
     * @summary Unban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unbanGroupMember: (groupId: string, userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Updates a Group and returns it.
     * @summary Update Group
     * @param {string} groupId Must be a valid group ID.
     * @param {UpdateGroupRequest} [updateGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroup: (groupId: string, updateGroupRequest?: UpdateGroupRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Updates a gallery for a Group.
     * @summary Update Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupGallery: (groupId: string, groupGalleryId: string, updateGroupGalleryRequest?: UpdateGroupGalleryRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Updates a Group Member
     * @summary Update Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMember: (groupId: string, userId: string, updateGroupMemberRequest?: UpdateGroupMemberRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Updates a group role by ID.
     * @summary Update Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupRole: (groupId: string, groupRoleId: string, updateGroupRoleRequest?: UpdateGroupRoleRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
export declare const GroupsApiFp: (configuration?: Configuration) => {
    /**
     * Adds an image to a Group gallery.
     * @summary Add Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {AddGroupGalleryImageRequest} [addGroupGalleryImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupGalleryImage(groupId: string, groupGalleryId: string, addGroupGalleryImageRequest?: AddGroupGalleryImageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupGalleryImage>>;
    /**
     * Adds a Role to a Group Member
     * @summary Add Role to GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>>;
    /**
     * Bans a user from a Group.
     * @summary Ban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {BanGroupMemberRequest} [banGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    banGroupMember(groupId: string, banGroupMemberRequest?: BanGroupMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>>;
    /**
     * Cancels a request sent to join the group.
     * @summary Cancel Group Join Request
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelGroupRequest(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
     * @summary Create Group
     * @param {CreateGroupRequest} [createGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(createGroupRequest?: CreateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>>;
    /**
     * Creates an Announcement for a Group.
     * @summary Create Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupAnnouncementRequest} [createGroupAnnouncementRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupAnnouncement(groupId: string, createGroupAnnouncementRequest?: CreateGroupAnnouncementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupAnnouncement>>;
    /**
     * Creates a gallery for a Group.
     * @summary Create Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupGalleryRequest} [createGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupGallery(groupId: string, createGroupGalleryRequest?: CreateGroupGalleryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupGallery>>;
    /**
     * Sends an invite to a user to join the group.
     * @summary Invite User to Group
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupInviteRequest} [createGroupInviteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupInvite(groupId: string, createGroupInviteRequest?: CreateGroupInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Create a Group role.
     * @summary Create GroupRole
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupRoleRequest} [createGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupRole(groupId: string, createGroupRoleRequest?: CreateGroupRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupRole>>;
    /**
     * Deletes a Group.
     * @summary Delete Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Deletes the announcement for a Group.
     * @summary Delete Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupAnnouncement(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Deletes a gallery for a Group.
     * @summary Delete Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupGallery(groupId: string, groupGalleryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Deletes an image from a Group gallery.
     * @summary Delete Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupGalleryImage(groupId: string, groupGalleryId: string, groupGalleryImageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Deletes an Group invite sent to a User
     * @summary Delete User Invite
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupInvite(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Deletes a Group Role by ID and returns the remaining roles.
     * @summary Delete Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupRole(groupId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupRole>>>;
    /**
     * Returns a single Group by ID.
     * @summary Get Group by ID
     * @param {string} groupId Must be a valid group ID.
     * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupId: string, includeRoles?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>>;
    /**
     * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
     * @summary Get Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupAnnouncements(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupAnnouncement>>;
    /**
     * Returns a list of audit logs for a Group.
     * @summary Get Group Audit Logs
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [startDate] The start date of the search range.
     * @param {string} [endDate] The end date of the search range.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupAuditLogs(groupId: string, n?: number, offset?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedGroupAuditLogEntryList>>;
    /**
     * Returns a list of banned users for a Group.
     * @summary Get Group Bans
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupBans(groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>>;
    /**
     * Returns a list of images for a Group gallery.
     * @summary Get Group Gallery Images
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupGalleryImages(groupId: string, groupGalleryId: string, n?: number, offset?: number, approved?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupGalleryImage>>>;
    /**
     * Returns a list of members that have been invited to the Group.
     * @summary Get Group Invites Sent
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupInvites(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>>;
    /**
     * Returns a LimitedGroup Member.
     * @summary Get Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupLimitedMember>>;
    /**
     * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
     * @summary List Group Members
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMembers(groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>>;
    /**
     * Returns a List of all possible/available permissions for a Group.
     * @summary List Group Permissions
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupPermissions(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupPermission>>>;
    /**
     * Returns a list of members that have requested to join the Group.
     * @summary Get Group Join Requests
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupRequests(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>>;
    /**
     * Returns a Group Role by ID.
     * @summary Get Group Roles
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupRoles(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupRole>>>;
    /**
     * Join a Group by ID and returns the joined Group.
     * @summary Join Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>>;
    /**
     * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
     * @summary Kick Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    kickGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Leave a group by ID.
     * @summary Leave Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGroup(groupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Removes a Role from a Group Member
     * @summary Remove Role from GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>>;
    /**
     * Responds to a Group Join Request with Accept/Deny
     * @summary Respond Group Join request
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {RespondGroupJoinRequest} [respondGroupJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondGroupJoinRequest(groupId: string, userId: string, respondGroupJoinRequest?: RespondGroupJoinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Unbans a user from a Group.
     * @summary Unban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unbanGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>>;
    /**
     * Updates a Group and returns it.
     * @summary Update Group
     * @param {string} groupId Must be a valid group ID.
     * @param {UpdateGroupRequest} [updateGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroup(groupId: string, updateGroupRequest?: UpdateGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>>;
    /**
     * Updates a gallery for a Group.
     * @summary Update Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupGallery(groupId: string, groupGalleryId: string, updateGroupGalleryRequest?: UpdateGroupGalleryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupGallery>>;
    /**
     * Updates a Group Member
     * @summary Update Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMember(groupId: string, userId: string, updateGroupMemberRequest?: UpdateGroupMemberRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupLimitedMember>>;
    /**
     * Updates a group role by ID.
     * @summary Update Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupRole(groupId: string, groupRoleId: string, updateGroupRoleRequest?: UpdateGroupRoleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupRole>>>;
};
/**
 * GroupsApi - factory interface
 * @export
 */
export declare const GroupsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Adds an image to a Group gallery.
     * @summary Add Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {AddGroupGalleryImageRequest} [addGroupGalleryImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupGalleryImage(groupId: string, groupGalleryId: string, addGroupGalleryImageRequest?: AddGroupGalleryImageRequest, options?: any): AxiosPromise<GroupGalleryImage>;
    /**
     * Adds a Role to a Group Member
     * @summary Add Role to GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: any): AxiosPromise<Array<string>>;
    /**
     * Bans a user from a Group.
     * @summary Ban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {BanGroupMemberRequest} [banGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    banGroupMember(groupId: string, banGroupMemberRequest?: BanGroupMemberRequest, options?: any): AxiosPromise<GroupMember>;
    /**
     * Cancels a request sent to join the group.
     * @summary Cancel Group Join Request
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelGroupRequest(groupId: string, options?: any): AxiosPromise<void>;
    /**
     * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
     * @summary Create Group
     * @param {CreateGroupRequest} [createGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(createGroupRequest?: CreateGroupRequest, options?: any): AxiosPromise<Group>;
    /**
     * Creates an Announcement for a Group.
     * @summary Create Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupAnnouncementRequest} [createGroupAnnouncementRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupAnnouncement(groupId: string, createGroupAnnouncementRequest?: CreateGroupAnnouncementRequest, options?: any): AxiosPromise<GroupAnnouncement>;
    /**
     * Creates a gallery for a Group.
     * @summary Create Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupGalleryRequest} [createGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupGallery(groupId: string, createGroupGalleryRequest?: CreateGroupGalleryRequest, options?: any): AxiosPromise<GroupGallery>;
    /**
     * Sends an invite to a user to join the group.
     * @summary Invite User to Group
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupInviteRequest} [createGroupInviteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupInvite(groupId: string, createGroupInviteRequest?: CreateGroupInviteRequest, options?: any): AxiosPromise<void>;
    /**
     * Create a Group role.
     * @summary Create GroupRole
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupRoleRequest} [createGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroupRole(groupId: string, createGroupRoleRequest?: CreateGroupRoleRequest, options?: any): AxiosPromise<GroupRole>;
    /**
     * Deletes a Group.
     * @summary Delete Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupId: string, options?: any): AxiosPromise<Success>;
    /**
     * Deletes the announcement for a Group.
     * @summary Delete Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupAnnouncement(groupId: string, options?: any): AxiosPromise<Success>;
    /**
     * Deletes a gallery for a Group.
     * @summary Delete Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupGallery(groupId: string, groupGalleryId: string, options?: any): AxiosPromise<Success>;
    /**
     * Deletes an image from a Group gallery.
     * @summary Delete Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupGalleryImage(groupId: string, groupGalleryId: string, groupGalleryImageId: string, options?: any): AxiosPromise<Success>;
    /**
     * Deletes an Group invite sent to a User
     * @summary Delete User Invite
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupInvite(groupId: string, userId: string, options?: any): AxiosPromise<void>;
    /**
     * Deletes a Group Role by ID and returns the remaining roles.
     * @summary Delete Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupRole(groupId: string, groupRoleId: string, options?: any): AxiosPromise<Array<GroupRole>>;
    /**
     * Returns a single Group by ID.
     * @summary Get Group by ID
     * @param {string} groupId Must be a valid group ID.
     * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroup(groupId: string, includeRoles?: boolean, options?: any): AxiosPromise<Group>;
    /**
     * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
     * @summary Get Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupAnnouncements(groupId: string, options?: any): AxiosPromise<GroupAnnouncement>;
    /**
     * Returns a list of audit logs for a Group.
     * @summary Get Group Audit Logs
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [startDate] The start date of the search range.
     * @param {string} [endDate] The end date of the search range.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupAuditLogs(groupId: string, n?: number, offset?: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<PaginatedGroupAuditLogEntryList>;
    /**
     * Returns a list of banned users for a Group.
     * @summary Get Group Bans
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupBans(groupId: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<GroupMember>>;
    /**
     * Returns a list of images for a Group gallery.
     * @summary Get Group Gallery Images
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupGalleryImages(groupId: string, groupGalleryId: string, n?: number, offset?: number, approved?: boolean, options?: any): AxiosPromise<Array<GroupGalleryImage>>;
    /**
     * Returns a list of members that have been invited to the Group.
     * @summary Get Group Invites Sent
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupInvites(groupId: string, options?: any): AxiosPromise<Array<GroupMember>>;
    /**
     * Returns a LimitedGroup Member.
     * @summary Get Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMember(groupId: string, userId: string, options?: any): AxiosPromise<GroupLimitedMember>;
    /**
     * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
     * @summary List Group Members
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupMembers(groupId: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<GroupMember>>;
    /**
     * Returns a List of all possible/available permissions for a Group.
     * @summary List Group Permissions
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupPermissions(groupId: string, options?: any): AxiosPromise<Array<GroupPermission>>;
    /**
     * Returns a list of members that have requested to join the Group.
     * @summary Get Group Join Requests
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupRequests(groupId: string, options?: any): AxiosPromise<Array<GroupMember>>;
    /**
     * Returns a Group Role by ID.
     * @summary Get Group Roles
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupRoles(groupId: string, options?: any): AxiosPromise<Array<GroupRole>>;
    /**
     * Join a Group by ID and returns the joined Group.
     * @summary Join Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinGroup(groupId: string, options?: any): AxiosPromise<Group>;
    /**
     * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
     * @summary Kick Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    kickGroupMember(groupId: string, userId: string, options?: any): AxiosPromise<void>;
    /**
     * Leave a group by ID.
     * @summary Leave Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGroup(groupId: string, options?: any): AxiosPromise<void>;
    /**
     * Removes a Role from a Group Member
     * @summary Remove Role from GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: any): AxiosPromise<Array<string>>;
    /**
     * Responds to a Group Join Request with Accept/Deny
     * @summary Respond Group Join request
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {RespondGroupJoinRequest} [respondGroupJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondGroupJoinRequest(groupId: string, userId: string, respondGroupJoinRequest?: RespondGroupJoinRequest, options?: any): AxiosPromise<void>;
    /**
     * Unbans a user from a Group.
     * @summary Unban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unbanGroupMember(groupId: string, userId: string, options?: any): AxiosPromise<GroupMember>;
    /**
     * Updates a Group and returns it.
     * @summary Update Group
     * @param {string} groupId Must be a valid group ID.
     * @param {UpdateGroupRequest} [updateGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroup(groupId: string, updateGroupRequest?: UpdateGroupRequest, options?: any): AxiosPromise<Group>;
    /**
     * Updates a gallery for a Group.
     * @summary Update Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupGallery(groupId: string, groupGalleryId: string, updateGroupGalleryRequest?: UpdateGroupGalleryRequest, options?: any): AxiosPromise<GroupGallery>;
    /**
     * Updates a Group Member
     * @summary Update Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupMember(groupId: string, userId: string, updateGroupMemberRequest?: UpdateGroupMemberRequest, options?: any): AxiosPromise<GroupLimitedMember>;
    /**
     * Updates a group role by ID.
     * @summary Update Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateGroupRole(groupId: string, groupRoleId: string, updateGroupRoleRequest?: UpdateGroupRoleRequest, options?: any): AxiosPromise<Array<GroupRole>>;
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export declare class GroupsApi extends BaseAPI {
    /**
     * Adds an image to a Group gallery.
     * @summary Add Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {AddGroupGalleryImageRequest} [addGroupGalleryImageRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    addGroupGalleryImage(groupId: string, groupGalleryId: string, addGroupGalleryImageRequest?: AddGroupGalleryImageRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupGalleryImage, any>>;
    /**
     * Adds a Role to a Group Member
     * @summary Add Role to GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    addGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<string[], any>>;
    /**
     * Bans a user from a Group.
     * @summary Ban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {BanGroupMemberRequest} [banGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    banGroupMember(groupId: string, banGroupMemberRequest?: BanGroupMemberRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupMember, any>>;
    /**
     * Cancels a request sent to join the group.
     * @summary Cancel Group Join Request
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    cancelGroupRequest(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
     * @summary Create Group
     * @param {CreateGroupRequest} [createGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroup(createGroupRequest?: CreateGroupRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Group, any>>;
    /**
     * Creates an Announcement for a Group.
     * @summary Create Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupAnnouncementRequest} [createGroupAnnouncementRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroupAnnouncement(groupId: string, createGroupAnnouncementRequest?: CreateGroupAnnouncementRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupAnnouncement, any>>;
    /**
     * Creates a gallery for a Group.
     * @summary Create Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupGalleryRequest} [createGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroupGallery(groupId: string, createGroupGalleryRequest?: CreateGroupGalleryRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupGallery, any>>;
    /**
     * Sends an invite to a user to join the group.
     * @summary Invite User to Group
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupInviteRequest} [createGroupInviteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroupInvite(groupId: string, createGroupInviteRequest?: CreateGroupInviteRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Create a Group role.
     * @summary Create GroupRole
     * @param {string} groupId Must be a valid group ID.
     * @param {CreateGroupRoleRequest} [createGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    createGroupRole(groupId: string, createGroupRoleRequest?: CreateGroupRoleRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupRole, any>>;
    /**
     * Deletes a Group.
     * @summary Delete Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroup(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Deletes the announcement for a Group.
     * @summary Delete Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroupAnnouncement(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Deletes a gallery for a Group.
     * @summary Delete Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroupGallery(groupId: string, groupGalleryId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Deletes an image from a Group gallery.
     * @summary Delete Group Gallery Image
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {string} groupGalleryImageId Must be a valid group gallery image ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroupGalleryImage(groupId: string, groupGalleryId: string, groupGalleryImageId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Deletes an Group invite sent to a User
     * @summary Delete User Invite
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroupInvite(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Deletes a Group Role by ID and returns the remaining roles.
     * @summary Delete Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroupRole(groupId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupRole[], any>>;
    /**
     * Returns a single Group by ID.
     * @summary Get Group by ID
     * @param {string} groupId Must be a valid group ID.
     * @param {boolean} [includeRoles] Include roles for the Group object. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroup(groupId: string, includeRoles?: boolean, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Group, any>>;
    /**
     * Returns the announcement for a Group. If no announcement has been made, then it returns **empty object**.  If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
     * @summary Get Group Announcement
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupAnnouncements(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupAnnouncement, any>>;
    /**
     * Returns a list of audit logs for a Group.
     * @summary Get Group Audit Logs
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [startDate] The start date of the search range.
     * @param {string} [endDate] The end date of the search range.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupAuditLogs(groupId: string, n?: number, offset?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PaginatedGroupAuditLogEntryList, any>>;
    /**
     * Returns a list of banned users for a Group.
     * @summary Get Group Bans
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupBans(groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupMember[], any>>;
    /**
     * Returns a list of images for a Group gallery.
     * @summary Get Group Gallery Images
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {boolean} [approved] If specified, only returns images that have been approved or not approved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupGalleryImages(groupId: string, groupGalleryId: string, n?: number, offset?: number, approved?: boolean, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupGalleryImage[], any>>;
    /**
     * Returns a list of members that have been invited to the Group.
     * @summary Get Group Invites Sent
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupInvites(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupMember[], any>>;
    /**
     * Returns a LimitedGroup Member.
     * @summary Get Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupLimitedMember, any>>;
    /**
     * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint. Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
     * @summary List Group Members
     * @param {string} groupId Must be a valid group ID.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupMembers(groupId: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupMember[], any>>;
    /**
     * Returns a List of all possible/available permissions for a Group.
     * @summary List Group Permissions
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupPermissions(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupPermission[], any>>;
    /**
     * Returns a list of members that have requested to join the Group.
     * @summary Get Group Join Requests
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupRequests(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupMember[], any>>;
    /**
     * Returns a Group Role by ID.
     * @summary Get Group Roles
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupRoles(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupRole[], any>>;
    /**
     * Join a Group by ID and returns the joined Group.
     * @summary Join Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    joinGroup(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Group, any>>;
    /**
     * Kicks a Group Member from the Group. The current user must have the \"Remove Group Members\" permission.
     * @summary Kick Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    kickGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Leave a group by ID.
     * @summary Leave Group
     * @param {string} groupId Must be a valid group ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    leaveGroup(groupId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Removes a Role from a Group Member
     * @summary Remove Role from GroupMember
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    removeGroupMemberRole(groupId: string, userId: string, groupRoleId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<string[], any>>;
    /**
     * Responds to a Group Join Request with Accept/Deny
     * @summary Respond Group Join request
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {RespondGroupJoinRequest} [respondGroupJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    respondGroupJoinRequest(groupId: string, userId: string, respondGroupJoinRequest?: RespondGroupJoinRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Unbans a user from a Group.
     * @summary Unban Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    unbanGroupMember(groupId: string, userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupMember, any>>;
    /**
     * Updates a Group and returns it.
     * @summary Update Group
     * @param {string} groupId Must be a valid group ID.
     * @param {UpdateGroupRequest} [updateGroupRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroup(groupId: string, updateGroupRequest?: UpdateGroupRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Group, any>>;
    /**
     * Updates a gallery for a Group.
     * @summary Update Group Gallery
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupGalleryId Must be a valid group gallery ID.
     * @param {UpdateGroupGalleryRequest} [updateGroupGalleryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupGallery(groupId: string, groupGalleryId: string, updateGroupGalleryRequest?: UpdateGroupGalleryRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupGallery, any>>;
    /**
     * Updates a Group Member
     * @summary Update Group Member
     * @param {string} groupId Must be a valid group ID.
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateGroupMemberRequest} [updateGroupMemberRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupMember(groupId: string, userId: string, updateGroupMemberRequest?: UpdateGroupMemberRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupLimitedMember, any>>;
    /**
     * Updates a group role by ID.
     * @summary Update Group Role
     * @param {string} groupId Must be a valid group ID.
     * @param {string} groupRoleId Must be a valid group role ID.
     * @param {UpdateGroupRoleRequest} [updateGroupRoleRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupRole(groupId: string, groupRoleId: string, updateGroupRoleRequest?: UpdateGroupRoleRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GroupRole[], any>>;
}
/**
 * InstancesApi - axios parameter creator
 * @export
 */
export declare const InstancesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
     * @summary Get Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstance: (worldId: string, instanceId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     * @summary Get Instance By Short Name
     * @param {string} shortName Must be a valid instance short name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceByShortName: (shortName: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns an instance short name.
     * @summary Get Instance Short Name
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShortName: (worldId: string, instanceId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Sends an invite to the instance to yourself.
     * @summary Send Self Invite
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSelfInvite: (worldId: string, instanceId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * InstancesApi - functional programming interface
 * @export
 */
export declare const InstancesApiFp: (configuration?: Configuration) => {
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
     * @summary Get Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstance(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>>;
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     * @summary Get Instance By Short Name
     * @param {string} shortName Must be a valid instance short name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceByShortName(shortName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>>;
    /**
     * Returns an instance short name.
     * @summary Get Instance Short Name
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShortName(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceShortNameResponse>>;
    /**
     * Sends an invite to the instance to yourself.
     * @summary Send Self Invite
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSelfInvite(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
};
/**
 * InstancesApi - factory interface
 * @export
 */
export declare const InstancesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
     * @summary Get Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstance(worldId: string, instanceId: string, options?: any): AxiosPromise<Instance>;
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     * @summary Get Instance By Short Name
     * @param {string} shortName Must be a valid instance short name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInstanceByShortName(shortName: string, options?: any): AxiosPromise<Instance>;
    /**
     * Returns an instance short name.
     * @summary Get Instance Short Name
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShortName(worldId: string, instanceId: string, options?: any): AxiosPromise<InstanceShortNameResponse>;
    /**
     * Sends an invite to the instance to yourself.
     * @summary Send Self Invite
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendSelfInvite(worldId: string, instanceId: string, options?: any): AxiosPromise<Success>;
};
/**
 * InstancesApi - object-oriented interface
 * @export
 * @class InstancesApi
 * @extends {BaseAPI}
 */
export declare class InstancesApi extends BaseAPI {
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.  If an invalid instanceId is provided, this endpoint will simply return \"null\"!
     * @summary Get Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    getInstance(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Instance, any>>;
    /**
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     * @summary Get Instance By Short Name
     * @param {string} shortName Must be a valid instance short name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    getInstanceByShortName(shortName: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Instance, any>>;
    /**
     * Returns an instance short name.
     * @summary Get Instance Short Name
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    getShortName(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InstanceShortNameResponse, any>>;
    /**
     * Sends an invite to the instance to yourself.
     * @summary Send Self Invite
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    sendSelfInvite(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
}
/**
 * InviteApi - axios parameter creator
 * @export
 */
export declare const InviteApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Get Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInviteMessage: (userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary List Invite Messages
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInviteMessages: (userId: string, messageType: InviteMessageType, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Sends self an invite to an instance
     * @summary Invite Myself To Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteMyselfTo: (worldId: string, instanceId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
     * @summary Invite User
     * @param {string} userId Must be a valid user ID.
     * @param {InviteRequest} [inviteRequest] Slot number of the Invite Message to use when inviting a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser: (userId: string, inviteRequest?: InviteRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     * @summary Request Invite
     * @param {string} userId Must be a valid user ID.
     * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInvite: (userId: string, requestInviteRequest?: RequestInviteRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
     * @summary Reset Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetInviteMessage: (userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
     * @summary Respond Invite
     * @param {string} notificationId Must be a valid notification ID.
     * @param {InviteResponse} [inviteResponse] Slot number of the Response Message to use when responding to a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondInvite: (notificationId: string, inviteResponse?: InviteResponse, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Update Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInviteMessage: (userId: string, messageType: InviteMessageType, slot: number, updateInviteMessageRequest?: UpdateInviteMessageRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * InviteApi - functional programming interface
 * @export
 */
export declare const InviteApiFp: (configuration?: Configuration) => {
    /**
     * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Get Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteMessage>>;
    /**
     * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary List Invite Messages
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInviteMessages(userId: string, messageType: InviteMessageType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InviteMessage>>>;
    /**
     * Sends self an invite to an instance
     * @summary Invite Myself To Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteMyselfTo(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SentNotification>>;
    /**
     * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
     * @summary Invite User
     * @param {string} userId Must be a valid user ID.
     * @param {InviteRequest} [inviteRequest] Slot number of the Invite Message to use when inviting a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser(userId: string, inviteRequest?: InviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SentNotification>>;
    /**
     * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     * @summary Request Invite
     * @param {string} userId Must be a valid user ID.
     * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInvite(userId: string, requestInviteRequest?: RequestInviteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>>;
    /**
     * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
     * @summary Reset Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InviteMessage>>>;
    /**
     * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
     * @summary Respond Invite
     * @param {string} notificationId Must be a valid notification ID.
     * @param {InviteResponse} [inviteResponse] Slot number of the Response Message to use when responding to a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondInvite(notificationId: string, inviteResponse?: InviteResponse, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>>;
    /**
     * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Update Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInviteMessage(userId: string, messageType: InviteMessageType, slot: number, updateInviteMessageRequest?: UpdateInviteMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InviteMessage>>>;
};
/**
 * InviteApi - factory interface
 * @export
 */
export declare const InviteApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Get Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: any): AxiosPromise<InviteMessage>;
    /**
     * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary List Invite Messages
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInviteMessages(userId: string, messageType: InviteMessageType, options?: any): AxiosPromise<Array<InviteMessage>>;
    /**
     * Sends self an invite to an instance
     * @summary Invite Myself To Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteMyselfTo(worldId: string, instanceId: string, options?: any): AxiosPromise<SentNotification>;
    /**
     * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
     * @summary Invite User
     * @param {string} userId Must be a valid user ID.
     * @param {InviteRequest} [inviteRequest] Slot number of the Invite Message to use when inviting a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    inviteUser(userId: string, inviteRequest?: InviteRequest, options?: any): AxiosPromise<SentNotification>;
    /**
     * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     * @summary Request Invite
     * @param {string} userId Must be a valid user ID.
     * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestInvite(userId: string, requestInviteRequest?: RequestInviteRequest, options?: any): AxiosPromise<Notification>;
    /**
     * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
     * @summary Reset Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: any): AxiosPromise<Array<InviteMessage>>;
    /**
     * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
     * @summary Respond Invite
     * @param {string} notificationId Must be a valid notification ID.
     * @param {InviteResponse} [inviteResponse] Slot number of the Response Message to use when responding to a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    respondInvite(notificationId: string, inviteResponse?: InviteResponse, options?: any): AxiosPromise<Notification>;
    /**
     * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Update Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInviteMessage(userId: string, messageType: InviteMessageType, slot: number, updateInviteMessageRequest?: UpdateInviteMessageRequest, options?: any): AxiosPromise<Array<InviteMessage>>;
};
/**
 * InviteApi - object-oriented interface
 * @export
 * @class InviteApi
 * @extends {BaseAPI}
 */
export declare class InviteApi extends BaseAPI {
    /**
     * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Get Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    getInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InviteMessage, any>>;
    /**
     * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary List Invite Messages
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    getInviteMessages(userId: string, messageType: InviteMessageType, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InviteMessage[], any>>;
    /**
     * Sends self an invite to an instance
     * @summary Invite Myself To Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    inviteMyselfTo(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SentNotification, any>>;
    /**
     * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
     * @summary Invite User
     * @param {string} userId Must be a valid user ID.
     * @param {InviteRequest} [inviteRequest] Slot number of the Invite Message to use when inviting a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    inviteUser(userId: string, inviteRequest?: InviteRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SentNotification, any>>;
    /**
     * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     * @summary Request Invite
     * @param {string} userId Must be a valid user ID.
     * @param {RequestInviteRequest} [requestInviteRequest] Slot number of the Request Message to use when request an invite.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    requestInvite(userId: string, requestInviteRequest?: RequestInviteRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Notification, any>>;
    /**
     * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown. Resetting it does however not set the rate-limit to 60 like when editing it. It is possible to edit it right after resetting it. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite  The DELETE endpoint does not have/require any request body.
     * @summary Reset Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    resetInviteMessage(userId: string, messageType: InviteMessageType, slot: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InviteMessage[], any>>;
    /**
     * Respond to an invite request by sending a world invite to the requesting user. `:notificationId` is the ID of the requesting notification.
     * @summary Respond Invite
     * @param {string} notificationId Must be a valid notification ID.
     * @param {InviteResponse} [inviteResponse] Slot number of the Response Message to use when responding to a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    respondInvite(notificationId: string, inviteResponse?: InviteResponse, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Notification, any>>;
    /**
     * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!  Updating a message automatically sets the cooldown timer to 60 minutes. Trying to edit a message before the cooldown timer expires results in a 429 \"Too Fast Error\".  Message type refers to a different collection of messages, used during different types of responses.  * `message` = Message during a normal invite * `response` = Message when replying to a message * `request` = Message when requesting an invite * `requestResponse` = Message when replying to a request for invite
     * @summary Update Invite Message
     * @param {string} userId Must be a valid user ID.
     * @param {InviteMessageType} messageType The type of message to fetch, must be a valid InviteMessageType.
     * @param {number} slot The message slot to fetch of a given message type.
     * @param {UpdateInviteMessageRequest} [updateInviteMessageRequest] Message of what to set the invite message to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InviteApi
     */
    updateInviteMessage(userId: string, messageType: InviteMessageType, slot: number, updateInviteMessageRequest?: UpdateInviteMessageRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InviteMessage[], any>>;
}
/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export declare const NotificationsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
     * @summary Accept Friend Request
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptFriendRequest: (notificationId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Clear **all** notifications.
     * @summary Clear All Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearNotifications: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete a notification.
     * @summary Delete Notification
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotification: (notificationId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve all of the current user\'s notifications.
     * @summary List Notifications
     * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
     * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
     * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
     * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotifications: (type?: string, sent?: boolean, hidden?: boolean, after?: string, n?: number, offset?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Mark a notification as seen.
     * @summary Mark Notification As Read
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markNotificationAsRead: (notificationId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * NotificationsApi - functional programming interface
 * @export
 */
export declare const NotificationsApiFp: (configuration?: Configuration) => {
    /**
     * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
     * @summary Accept Friend Request
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptFriendRequest(notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Clear **all** notifications.
     * @summary Clear All Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearNotifications(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Delete a notification.
     * @summary Delete Notification
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotification(notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>>;
    /**
     * Retrieve all of the current user\'s notifications.
     * @summary List Notifications
     * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
     * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
     * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
     * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotifications(type?: string, sent?: boolean, hidden?: boolean, after?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>>;
    /**
     * Mark a notification as seen.
     * @summary Mark Notification As Read
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markNotificationAsRead(notificationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>>;
};
/**
 * NotificationsApi - factory interface
 * @export
 */
export declare const NotificationsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
     * @summary Accept Friend Request
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptFriendRequest(notificationId: string, options?: any): AxiosPromise<Success>;
    /**
     * Clear **all** notifications.
     * @summary Clear All Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearNotifications(options?: any): AxiosPromise<Success>;
    /**
     * Delete a notification.
     * @summary Delete Notification
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotification(notificationId: string, options?: any): AxiosPromise<Notification>;
    /**
     * Retrieve all of the current user\'s notifications.
     * @summary List Notifications
     * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
     * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
     * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
     * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotifications(type?: string, sent?: boolean, hidden?: boolean, after?: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<Notification>>;
    /**
     * Mark a notification as seen.
     * @summary Mark Notification As Read
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markNotificationAsRead(notificationId: string, options?: any): AxiosPromise<Notification>;
};
/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export declare class NotificationsApi extends BaseAPI {
    /**
     * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
     * @summary Accept Friend Request
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    acceptFriendRequest(notificationId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Clear **all** notifications.
     * @summary Clear All Notifications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    clearNotifications(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Delete a notification.
     * @summary Delete Notification
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    deleteNotification(notificationId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Notification, any>>;
    /**
     * Retrieve all of the current user\'s notifications.
     * @summary List Notifications
     * @param {string} [type] Only send notifications of this type (can use &#x60;all&#x60; for all). This parameter no longer does anything, and is deprecated.
     * @param {boolean} [sent] Return notifications sent by the user. Must be false or omitted.
     * @param {boolean} [hidden] Whether to return hidden or non-hidden notifications. True only allowed on type &#x60;friendRequest&#x60;.
     * @param {string} [after] Only return notifications sent after this Date. Ignored if type is &#x60;friendRequest&#x60;.
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    getNotifications(type?: string, sent?: boolean, hidden?: boolean, after?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Notification[], any>>;
    /**
     * Mark a notification as seen.
     * @summary Mark Notification As Read
     * @param {string} notificationId Must be a valid notification ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    markNotificationAsRead(notificationId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Notification, any>>;
}
/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export declare const PermissionsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
     * @summary Get Assigned Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssignedPermissions: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
     * @summary Get Permission
     * @param {string} permissionId Must be a valid permission ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermission: (permissionId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PermissionsApi - functional programming interface
 * @export
 */
export declare const PermissionsApiFp: (configuration?: Configuration) => {
    /**
     * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
     * @summary Get Assigned Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssignedPermissions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Permission>>>;
    /**
     * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
     * @summary Get Permission
     * @param {string} permissionId Must be a valid permission ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermission(permissionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>>;
};
/**
 * PermissionsApi - factory interface
 * @export
 */
export declare const PermissionsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
     * @summary Get Assigned Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssignedPermissions(options?: any): AxiosPromise<Array<Permission>>;
    /**
     * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
     * @summary Get Permission
     * @param {string} permissionId Must be a valid permission ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPermission(permissionId: string, options?: any): AxiosPromise<Permission>;
};
/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export declare class PermissionsApi extends BaseAPI {
    /**
     * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
     * @summary Get Assigned Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    getAssignedPermissions(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Permission[], any>>;
    /**
     * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
     * @summary Get Permission
     * @param {string} permissionId Must be a valid permission ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionsApi
     */
    getPermission(permissionId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Permission, any>>;
}
/**
 * PlayermoderationApi - axios parameter creator
 * @export
 */
export declare const PlayermoderationApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     *  **This will delete every single player moderation you\'ve ever made.**
     * @summary Clear All Player Moderations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearAllPlayerModerations: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes a specific player moderation based on it\'s `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
     * @summary Delete Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePlayerModeration: (playerModerationId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
     * @summary Get Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerModeration: (playerModerationId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
     * @summary Search Player Moderations
     * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
     * @param {string} [targetUserId] Must be valid UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerModerations: (type?: string, targetUserId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
     * @summary Moderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderateUser: (moderateUserRequest?: ModerateUserRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
     * @summary Unmoderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unmoderateUser: (moderateUserRequest?: ModerateUserRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * PlayermoderationApi - functional programming interface
 * @export
 */
export declare const PlayermoderationApiFp: (configuration?: Configuration) => {
    /**
     *  **This will delete every single player moderation you\'ve ever made.**
     * @summary Clear All Player Moderations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearAllPlayerModerations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Deletes a specific player moderation based on it\'s `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
     * @summary Delete Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePlayerModeration(playerModerationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
    /**
     * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
     * @summary Get Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerModeration(playerModerationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerModeration>>;
    /**
     * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
     * @summary Search Player Moderations
     * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
     * @param {string} [targetUserId] Must be valid UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerModerations(type?: string, targetUserId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerModeration>>>;
    /**
     * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
     * @summary Moderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderateUser(moderateUserRequest?: ModerateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerModeration>>;
    /**
     * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
     * @summary Unmoderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unmoderateUser(moderateUserRequest?: ModerateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>>;
};
/**
 * PlayermoderationApi - factory interface
 * @export
 */
export declare const PlayermoderationApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     *  **This will delete every single player moderation you\'ve ever made.**
     * @summary Clear All Player Moderations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    clearAllPlayerModerations(options?: any): AxiosPromise<Success>;
    /**
     * Deletes a specific player moderation based on it\'s `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
     * @summary Delete Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePlayerModeration(playerModerationId: string, options?: any): AxiosPromise<Success>;
    /**
     * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
     * @summary Get Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerModeration(playerModerationId: string, options?: any): AxiosPromise<PlayerModeration>;
    /**
     * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
     * @summary Search Player Moderations
     * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
     * @param {string} [targetUserId] Must be valid UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerModerations(type?: string, targetUserId?: string, options?: any): AxiosPromise<Array<PlayerModeration>>;
    /**
     * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
     * @summary Moderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moderateUser(moderateUserRequest?: ModerateUserRequest, options?: any): AxiosPromise<PlayerModeration>;
    /**
     * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
     * @summary Unmoderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unmoderateUser(moderateUserRequest?: ModerateUserRequest, options?: any): AxiosPromise<Success>;
};
/**
 * PlayermoderationApi - object-oriented interface
 * @export
 * @class PlayermoderationApi
 * @extends {BaseAPI}
 */
export declare class PlayermoderationApi extends BaseAPI {
    /**
     *  **This will delete every single player moderation you\'ve ever made.**
     * @summary Clear All Player Moderations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    clearAllPlayerModerations(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Deletes a specific player moderation based on it\'s `pmod_` ID. The website uses `unmoderateUser` instead. You can delete the same player moderation multiple times successfully.
     * @summary Delete Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    deletePlayerModeration(playerModerationId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
    /**
     * Returns a single Player Moderation. This returns the exact same amount of information as the more generalised `getPlayerModerations`.
     * @summary Get Player Moderation
     * @param {string} playerModerationId Must be a valid &#x60;pmod_&#x60; ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    getPlayerModeration(playerModerationId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PlayerModeration, any>>;
    /**
     * Returns a list of all player moderations made by **you**.  This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
     * @summary Search Player Moderations
     * @param {string} [type] Must be one of PlayerModerationType, except unblock. Unblocking simply removes a block.
     * @param {string} [targetUserId] Must be valid UserID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    getPlayerModerations(type?: string, targetUserId?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PlayerModeration[], any>>;
    /**
     * Moderate a user, e.g. unmute them or show their avatar.  Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
     * @summary Moderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    moderateUser(moderateUserRequest?: ModerateUserRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<PlayerModeration, any>>;
    /**
     * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
     * @summary Unmoderate User
     * @param {ModerateUserRequest} [moderateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayermoderationApi
     */
    unmoderateUser(moderateUserRequest?: ModerateUserRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Success, any>>;
}
/**
 * SystemApi - axios parameter creator
 * @export
 */
export declare const SystemApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Fetches the CSS code to the frontend React website.
     * @summary Download CSS
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCSS: (variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
     * @summary Fetch API Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     * @summary Current Online Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentOnlineUsers: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     * @summary Check API Health
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getHealth: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
     * @summary Show Information Notices
     * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
     * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfoPush: (require?: string, include?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Fetches the JavaScript code to the frontend React website.
     * @summary Download JavaScript
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJavaScript: (variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
     * @summary Current System Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemTime: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * SystemApi - functional programming interface
 * @export
 */
export declare const SystemApiFp: (configuration?: Configuration) => {
    /**
     * Fetches the CSS code to the frontend React website.
     * @summary Download CSS
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCSS(variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
     * @summary Fetch API Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIConfig>>;
    /**
     * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     * @summary Current Online Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentOnlineUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>>;
    /**
     * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     * @summary Check API Health
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getHealth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIHealth>>;
    /**
     * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
     * @summary Show Information Notices
     * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
     * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfoPush(require?: string, include?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InfoPush>>>;
    /**
     * Fetches the JavaScript code to the frontend React website.
     * @summary Download JavaScript
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJavaScript(variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
    /**
     * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
     * @summary Current System Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemTime(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>>;
};
/**
 * SystemApi - factory interface
 * @export
 */
export declare const SystemApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Fetches the CSS code to the frontend React website.
     * @summary Download CSS
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCSS(variant?: 'public' | 'internal', branch?: string, options?: any): AxiosPromise<string>;
    /**
     * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
     * @summary Fetch API Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig(options?: any): AxiosPromise<APIConfig>;
    /**
     * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     * @summary Current Online Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentOnlineUsers(options?: any): AxiosPromise<number>;
    /**
     * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     * @summary Check API Health
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getHealth(options?: any): AxiosPromise<APIHealth>;
    /**
     * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
     * @summary Show Information Notices
     * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
     * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfoPush(require?: string, include?: string, options?: any): AxiosPromise<Array<InfoPush>>;
    /**
     * Fetches the JavaScript code to the frontend React website.
     * @summary Download JavaScript
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJavaScript(variant?: 'public' | 'internal', branch?: string, options?: any): AxiosPromise<string>;
    /**
     * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
     * @summary Current System Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemTime(options?: any): AxiosPromise<string>;
};
/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export declare class SystemApi extends BaseAPI {
    /**
     * Fetches the CSS code to the frontend React website.
     * @summary Download CSS
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    getCSS(variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<string, any>>;
    /**
     * API config contains configuration that the clients needs to work properly.  Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
     * @summary Fetch API Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    getConfig(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<APIConfig, any>>;
    /**
     * Returns the current number of online users.  **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     * @summary Current Online Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    getCurrentOnlineUsers(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<number, any>>;
    /**
     * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~  **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     * @summary Check API Health
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    getHealth(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<APIHealth, any>>;
    /**
     * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.  `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an \"any of\" search.  `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an \"all of\" search.
     * @summary Show Information Notices
     * @param {string} [require] Tags to include (comma-separated). All of the tags needs to be present.
     * @param {string} [include] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    getInfoPush(require?: string, include?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InfoPush[], any>>;
    /**
     * Fetches the JavaScript code to the frontend React website.
     * @summary Download JavaScript
     * @param {'public' | 'internal'} [variant] Specifies which &#x60;variant&#x60; of the site. Public is the end-user site, while &#x60;internal&#x60; is the staff-only site with special pages for moderation and management.
     * @param {string} [branch] Specifies which git branch the site should load frontend source code from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    getJavaScript(variant?: 'public' | 'internal', branch?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<string, any>>;
    /**
     * Returns the current time of the API server.  **NOTE:** The response type is not a JSON object, but a simple JSON string.
     * @summary Current System Time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    getSystemTime(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<string, any>>;
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
export declare const UsersApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Get public user information about a specific user using their ID.
     * @summary Get User by ID
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
     * @summary Get User by Username
     * @param {string} username Username of the user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getUserByName: (username: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a list of Groups the user has requested to be invited into.
     * @summary Get User Group Requests
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroupRequests: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get user\'s public groups
     * @summary Get User Groups
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroups: (userId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Search and list any users by text query
     * @summary Search All Users
     * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
     * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers: (search?: string, developerType?: string, n?: number, offset?: number, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update a users information such as the email and birthday.
     * @summary Update User Info
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateUserRequest} [updateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: (userId: string, updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export declare const UsersApiFp: (configuration?: Configuration) => {
    /**
     * Get public user information about a specific user using their ID.
     * @summary Get User by ID
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>>;
    /**
     * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
     * @summary Get User by Username
     * @param {string} username Username of the user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getUserByName(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>>;
    /**
     * Returns a list of Groups the user has requested to be invited into.
     * @summary Get User Group Requests
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroupRequests(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>>;
    /**
     * Get user\'s public groups
     * @summary Get User Groups
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroups(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>>;
    /**
     * Search and list any users by text query
     * @summary Search All Users
     * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
     * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers(search?: string, developerType?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedUser>>>;
    /**
     * Update a users information such as the email and birthday.
     * @summary Update User Info
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateUserRequest} [updateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUser>>;
};
/**
 * UsersApi - factory interface
 * @export
 */
export declare const UsersApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Get public user information about a specific user using their ID.
     * @summary Get User by ID
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userId: string, options?: any): AxiosPromise<User>;
    /**
     * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
     * @summary Get User by Username
     * @param {string} username Username of the user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getUserByName(username: string, options?: any): AxiosPromise<User>;
    /**
     * Returns a list of Groups the user has requested to be invited into.
     * @summary Get User Group Requests
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroupRequests(userId: string, options?: any): AxiosPromise<Array<Group>>;
    /**
     * Get user\'s public groups
     * @summary Get User Groups
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserGroups(userId: string, options?: any): AxiosPromise<Array<Group>>;
    /**
     * Search and list any users by text query
     * @summary Search All Users
     * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
     * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUsers(search?: string, developerType?: string, n?: number, offset?: number, options?: any): AxiosPromise<Array<LimitedUser>>;
    /**
     * Update a users information such as the email and birthday.
     * @summary Update User Info
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateUserRequest} [updateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: any): AxiosPromise<CurrentUser>;
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export declare class UsersApi extends BaseAPI {
    /**
     * Get public user information about a specific user using their ID.
     * @summary Get User by ID
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUser(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<User, any>>;
    /**
     * ~~Get public user information about a specific user using their name.~~  **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429). This endpoint now require Admin Credentials.
     * @summary Get User by Username
     * @param {string} username Username of the user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserByName(username: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<User, any>>;
    /**
     * Returns a list of Groups the user has requested to be invited into.
     * @summary Get User Group Requests
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserGroupRequests(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Group[], any>>;
    /**
     * Get user\'s public groups
     * @summary Get User Groups
     * @param {string} userId Must be a valid user ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUserGroups(userId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Group[], any>>;
    /**
     * Search and list any users by text query
     * @summary Search All Users
     * @param {string} [search] Searches by &#x60;displayName&#x60;. Will return empty array if search query is empty or missing.
     * @param {string} [developerType] Active user by developer type, none for normal users and internal for moderators
     * @param {number} [n] The number of objects to return.
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    searchUsers(search?: string, developerType?: string, n?: number, offset?: number, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LimitedUser[], any>>;
    /**
     * Update a users information such as the email and birthday.
     * @summary Update User Info
     * @param {string} userId Must be a valid user ID.
     * @param {UpdateUserRequest} [updateUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    updateUser(userId: string, updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<CurrentUser, any>>;
}
/**
 * WorldsApi - axios parameter creator
 * @export
 */
export declare const WorldsApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
     * @summary Create World
     * @param {CreateWorldRequest} [createWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorld: (createWorldRequest?: CreateWorldRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
     * @summary Delete World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorld: (worldId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Search and list currently Active worlds by query filters.
     * @summary List Active Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveWorlds: (featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Search and list favorited worlds by query filters.
     * @summary List Favorited Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritedWorlds: (featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Search and list recently visited worlds by query filters.
     * @summary List Recent Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentWorlds: (featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
     * @summary Get World by ID
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorld: (worldId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a worlds instance.
     * @summary Get World Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorldInstance: (worldId: string, instanceId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
     * @summary Get World Metadata
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getWorldMetadata: (worldId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns a worlds publish status.
     * @summary Get World Publish Status
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorldPublishStatus: (worldId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Publish a world. You can only publish one world per week.
     * @summary Publish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishWorld: (worldId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Search and list any worlds by query filters.
     * @summary Search All Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchWorlds: (featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Unpublish a world.
     * @summary Unpublish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublishWorld: (worldId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update information about a specific World.
     * @summary Update World
     * @param {string} worldId Must be a valid world ID.
     * @param {UpdateWorldRequest} [updateWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWorld: (worldId: string, updateWorldRequest?: UpdateWorldRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WorldsApi - functional programming interface
 * @export
 */
export declare const WorldsApiFp: (configuration?: Configuration) => {
    /**
     * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
     * @summary Create World
     * @param {CreateWorldRequest} [createWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorld(createWorldRequest?: CreateWorldRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<World>>;
    /**
     * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
     * @summary Delete World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorld(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Search and list currently Active worlds by query filters.
     * @summary List Active Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedWorld>>>;
    /**
     * Search and list favorited worlds by query filters.
     * @summary List Favorited Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritedWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedWorld>>>;
    /**
     * Search and list recently visited worlds by query filters.
     * @summary List Recent Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedWorld>>>;
    /**
     * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
     * @summary Get World by ID
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorld(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<World>>;
    /**
     * Returns a worlds instance.
     * @summary Get World Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorldInstance(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instance>>;
    /**
     * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
     * @summary Get World Metadata
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getWorldMetadata(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldMetadata>>;
    /**
     * Returns a worlds publish status.
     * @summary Get World Publish Status
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorldPublishStatus(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorldPublishStatus>>;
    /**
     * Publish a world. You can only publish one world per week.
     * @summary Publish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishWorld(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Search and list any worlds by query filters.
     * @summary Search All Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchWorlds(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LimitedWorld>>>;
    /**
     * Unpublish a world.
     * @summary Unpublish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublishWorld(worldId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Update information about a specific World.
     * @summary Update World
     * @param {string} worldId Must be a valid world ID.
     * @param {UpdateWorldRequest} [updateWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWorld(worldId: string, updateWorldRequest?: UpdateWorldRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<World>>;
};
/**
 * WorldsApi - factory interface
 * @export
 */
export declare const WorldsApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
     * @summary Create World
     * @param {CreateWorldRequest} [createWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWorld(createWorldRequest?: CreateWorldRequest, options?: any): AxiosPromise<World>;
    /**
     * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
     * @summary Delete World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWorld(worldId: string, options?: any): AxiosPromise<void>;
    /**
     * Search and list currently Active worlds by query filters.
     * @summary List Active Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: any): AxiosPromise<Array<LimitedWorld>>;
    /**
     * Search and list favorited worlds by query filters.
     * @summary List Favorited Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFavoritedWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: any): AxiosPromise<Array<LimitedWorld>>;
    /**
     * Search and list recently visited worlds by query filters.
     * @summary List Recent Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRecentWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: any): AxiosPromise<Array<LimitedWorld>>;
    /**
     * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
     * @summary Get World by ID
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorld(worldId: string, options?: any): AxiosPromise<World>;
    /**
     * Returns a worlds instance.
     * @summary Get World Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorldInstance(worldId: string, instanceId: string, options?: any): AxiosPromise<Instance>;
    /**
     * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
     * @summary Get World Metadata
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getWorldMetadata(worldId: string, options?: any): AxiosPromise<WorldMetadata>;
    /**
     * Returns a worlds publish status.
     * @summary Get World Publish Status
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWorldPublishStatus(worldId: string, options?: any): AxiosPromise<WorldPublishStatus>;
    /**
     * Publish a world. You can only publish one world per week.
     * @summary Publish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    publishWorld(worldId: string, options?: any): AxiosPromise<void>;
    /**
     * Search and list any worlds by query filters.
     * @summary Search All Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchWorlds(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: any): AxiosPromise<Array<LimitedWorld>>;
    /**
     * Unpublish a world.
     * @summary Unpublish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unpublishWorld(worldId: string, options?: any): AxiosPromise<void>;
    /**
     * Update information about a specific World.
     * @summary Update World
     * @param {string} worldId Must be a valid world ID.
     * @param {UpdateWorldRequest} [updateWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWorld(worldId: string, updateWorldRequest?: UpdateWorldRequest, options?: any): AxiosPromise<World>;
};
/**
 * WorldsApi - object-oriented interface
 * @export
 * @class WorldsApi
 * @extends {BaseAPI}
 */
export declare class WorldsApi extends BaseAPI {
    /**
     * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
     * @summary Create World
     * @param {CreateWorldRequest} [createWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    createWorld(createWorldRequest?: CreateWorldRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<World, any>>;
    /**
     * Delete a world. Notice a world is never fully \"deleted\", only its ReleaseStatus is set to \"hidden\" and the linked Files are deleted. The WorldID is permanently reserved.
     * @summary Delete World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    deleteWorld(worldId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Search and list currently Active worlds by query filters.
     * @summary List Active Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    getActiveWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LimitedWorld[], any>>;
    /**
     * Search and list favorited worlds by query filters.
     * @summary List Favorited Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    getFavoritedWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LimitedWorld[], any>>;
    /**
     * Search and list recently visited worlds by query filters.
     * @summary List Recent Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {string} [userId] Target user to see information on, admin-only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    getRecentWorlds(featured?: boolean, sort?: SortOption, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, userId?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LimitedWorld[], any>>;
    /**
     * Get information about a specific World. Works unauthenticated but when so will always return `0` for certain fields.
     * @summary Get World by ID
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    getWorld(worldId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<World, any>>;
    /**
     * Returns a worlds instance.
     * @summary Get World Instance
     * @param {string} worldId Must be a valid world ID.
     * @param {string} instanceId Must be a valid instance ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    getWorldInstance(worldId: string, instanceId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Instance, any>>;
    /**
     * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
     * @summary Get World Metadata
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    getWorldMetadata(worldId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<WorldMetadata, any>>;
    /**
     * Returns a worlds publish status.
     * @summary Get World Publish Status
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    getWorldPublishStatus(worldId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<WorldPublishStatus, any>>;
    /**
     * Publish a world. You can only publish one world per week.
     * @summary Publish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    publishWorld(worldId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Search and list any worlds by query filters.
     * @summary Search All Worlds
     * @param {boolean} [featured] Filters on featured results.
     * @param {SortOption} [sort] The sort order of the results.
     * @param {'me'} [user] Set to &#x60;me&#x60; for searching own worlds.
     * @param {string} [userId] Filter by UserID.
     * @param {number} [n] The number of objects to return.
     * @param {OrderOption} [order] Result ordering
     * @param {number} [offset] A zero-based offset from the default object sorting from where search results start.
     * @param {string} [search] Filters by world name.
     * @param {string} [tag] Tags to include (comma-separated). Any of the tags needs to be present.
     * @param {string} [notag] Tags to exclude (comma-separated).
     * @param {ReleaseStatus} [releaseStatus] Filter by ReleaseStatus.
     * @param {string} [maxUnityVersion] The maximum Unity version supported by the asset.
     * @param {string} [minUnityVersion] The minimum Unity version supported by the asset.
     * @param {string} [platform] The platform the asset supports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    searchWorlds(featured?: boolean, sort?: SortOption, user?: 'me', userId?: string, n?: number, order?: OrderOption, offset?: number, search?: string, tag?: string, notag?: string, releaseStatus?: ReleaseStatus, maxUnityVersion?: string, minUnityVersion?: string, platform?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<LimitedWorld[], any>>;
    /**
     * Unpublish a world.
     * @summary Unpublish World
     * @param {string} worldId Must be a valid world ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    unpublishWorld(worldId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Update information about a specific World.
     * @summary Update World
     * @param {string} worldId Must be a valid world ID.
     * @param {UpdateWorldRequest} [updateWorldRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorldsApi
     */
    updateWorld(worldId: string, updateWorldRequest?: UpdateWorldRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<World, any>>;
}
