
let cameras = 
[
    {
        id: 0,
        img_name: "00001",
        width: 1959,
        height: 1090,
        position: [
            -3.0089893469241797, -0.11086489695181866, -3.7527640949141428,
        ],
        rotation: [
            [0.876134201218856, 0.06925962026449776, 0.47706599800804744],
            [-0.04747421839895102, 0.9972110940209488, -0.057586739349882114],
            [-0.4797239414934443, 0.027805376500959853, 0.8769787916452908],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 1,
        img_name: "00009",
        width: 1959,
        height: 1090,
        position: [
            -2.5199776022057296, -0.09704735754873686, -3.6247725540304545,
        ],
        rotation: [
            [0.9982731285632193, -0.011928707708098955, -0.05751927260507243],
            [0.0065061360949636325, 0.9955928229282383, -0.09355533724430458],
            [0.058381769258182864, 0.09301955098900708, 0.9939511719154457],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 2,
        img_name: "00017",
        width: 1959,
        height: 1090,
        position: [
            -0.7737533667465242, -0.3364271945329695, -2.9358969417573753,
        ],
        rotation: [
            [0.9998813418672372, 0.013742375651625236, -0.0069605529394208224],
            [-0.014268370388586709, 0.996512943252834, -0.08220929105659476],
            [0.00580653013657589, 0.08229885200307129, 0.9965907801935302],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 3,
        img_name: "00025",
        width: 1959,
        height: 1090,
        position: [
            1.2198221749590001, -0.2196687861401182, -2.3183162007028453,
        ],
        rotation: [
            [0.9208648867765482, 0.0012010625395201253, 0.389880004297208],
            [-0.06298204172269357, 0.987319521752825, 0.14571693239364383],
            [-0.3847611242348369, -0.1587410451475895, 0.9092635249821667],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 4,
        img_name: "00033",
        width: 1959,
        height: 1090,
        position: [
            1.742387858893817, -0.13848225198886954, -2.0566370113193146,
        ],
        rotation: [
            [0.24669889292141334, -0.08370189346592856, -0.9654706879349405],
            [0.11343747891376445, 0.9919082664242816, -0.05700815184573074],
            [0.9624300466054861, -0.09545671285663988, 0.2541976029815521],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 5,
        img_name: "00041",
        width: 1959,
        height: 1090,
        position: [
            3.6567309419223935, -0.16470990600750707, -1.3458085590422042,
        ],
        rotation: [
            [0.2341293058324528, -0.02968330457755884, -0.9717522161434825],
            [0.10270823606832301, 0.99469554638321, -0.005638106875665722],
            [0.9667649592295676, -0.09848690996657204, 0.2359360976431732],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 6,
        img_name: "00049",
        width: 1959,
        height: 1090,
        position: [
            3.9013554243203497, -0.2597500978038105, -0.8106154188297828,
        ],
        rotation: [
            [0.6717235545638952, -0.015718162115524837, -0.7406351366386528],
            [0.055627354673906296, 0.9980224478387622, 0.029270992841185218],
            [0.7387104058127439, -0.060861588786650656, 0.6712695459756353],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 7,
        img_name: "00057",
        width: 1959,
        height: 1090,
        position: [4.742994605467533, -0.05591660945412069, 0.9500365976084458],
        rotation: [
            [-0.17042655709210375, 0.01207080756938, -0.9852964448542146],
            [0.1165090336695526, 0.9931575292530063, -0.00798543433078162],
            [0.9784581921120181, -0.1161568667478904, -0.1706667764862097],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 8,
        img_name: "00065",
        width: 1959,
        height: 1090,
        position: [4.34676307626522, 0.08168160516967145, 1.0876221470355405],
        rotation: [
            [-0.003575447631888379, -0.044792503246552894, -0.9989899137764799],
            [0.10770152645126597, 0.9931680875192705, -0.04491693593046672],
            [0.9941768441149182, -0.10775333677534978, 0.0012732004866391048],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 9,
        img_name: "00073",
        width: 1959,
        height: 1090,
        position: [3.264984351114202, 0.078974937336732, 1.0117200284114904],
        rotation: [
            [-0.026919994628162257, -0.1565891128261527, -0.9872968974090509],
            [0.08444552208239385, 0.983768234577625, -0.1583319754069128],
            [0.9960643893290491, -0.0876350978794554, -0.013259786205163005],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
];

let camera = cameras[0];

function getProjectionMatrix(fx, fy, width, height) {
    const znear = 0.2;
    const zfar = 1000;
    return [
        [(2 * fx) / width, 0, 0, 0],
        [0, -(2 * fy) / height, 0, 0],
        [0, 0, zfar / (zfar - znear), 1],
        [0, 0, -(zfar * znear) / (zfar - znear), 0],
    ].flat();
}

function getViewMatrix(camera) {
    const R = camera.rotation.flat();
    const t = camera.position;
    const camToWorld = [
        [R[0], R[1], R[2], 0],
        [R[3], R[4], R[5], 0],
        [R[6], R[7], R[8], 0],
        [
            -t[0] * R[0] - t[1] * R[3] - t[2] * R[6],
            -t[0] * R[1] - t[1] * R[4] - t[2] * R[7],
            -t[0] * R[2] - t[1] * R[5] - t[2] * R[8],
            1,
        ],
    ].flat();
    return camToWorld;
}

function multiply4(a, b) {
    return [
        b[0] * a[0] + b[1] * a[4] + b[2] * a[8] + b[3] * a[12],
        b[0] * a[1] + b[1] * a[5] + b[2] * a[9] + b[3] * a[13],
        b[0] * a[2] + b[1] * a[6] + b[2] * a[10] + b[3] * a[14],
        b[0] * a[3] + b[1] * a[7] + b[2] * a[11] + b[3] * a[15],
        b[4] * a[0] + b[5] * a[4] + b[6] * a[8] + b[7] * a[12],
        b[4] * a[1] + b[5] * a[5] + b[6] * a[9] + b[7] * a[13],
        b[4] * a[2] + b[5] * a[6] + b[6] * a[10] + b[7] * a[14],
        b[4] * a[3] + b[5] * a[7] + b[6] * a[11] + b[7] * a[15],
        b[8] * a[0] + b[9] * a[4] + b[10] * a[8] + b[11] * a[12],
        b[8] * a[1] + b[9] * a[5] + b[10] * a[9] + b[11] * a[13],
        b[8] * a[2] + b[9] * a[6] + b[10] * a[10] + b[11] * a[14],
        b[8] * a[3] + b[9] * a[7] + b[10] * a[11] + b[11] * a[15],
        b[12] * a[0] + b[13] * a[4] + b[14] * a[8] + b[15] * a[12],
        b[12] * a[1] + b[13] * a[5] + b[14] * a[9] + b[15] * a[13],
        b[12] * a[2] + b[13] * a[6] + b[14] * a[10] + b[15] * a[14],
        b[12] * a[3] + b[13] * a[7] + b[14] * a[11] + b[15] * a[15],
    ];
}

function invert4(a) {
    let b00 = a[0] * a[5] - a[1] * a[4];
    let b01 = a[0] * a[6] - a[2] * a[4];
    let b02 = a[0] * a[7] - a[3] * a[4];
    let b03 = a[1] * a[6] - a[2] * a[5];
    let b04 = a[1] * a[7] - a[3] * a[5];
    let b05 = a[2] * a[7] - a[3] * a[6];
    let b06 = a[8] * a[13] - a[9] * a[12];
    let b07 = a[8] * a[14] - a[10] * a[12];
    let b08 = a[8] * a[15] - a[11] * a[12];
    let b09 = a[9] * a[14] - a[10] * a[13];
    let b10 = a[9] * a[15] - a[11] * a[13];
    let b11 = a[10] * a[15] - a[11] * a[14];
    let det =
        b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    return [
        (a[5] * b11 - a[6] * b10 + a[7] * b09) / det,
        (a[2] * b10 - a[1] * b11 - a[3] * b09) / det,
        (a[13] * b05 - a[14] * b04 + a[15] * b03) / det,
        (a[10] * b04 - a[9] * b05 - a[11] * b03) / det,
        (a[6] * b08 - a[4] * b11 - a[7] * b07) / det,
        (a[0] * b11 - a[2] * b08 + a[3] * b07) / det,
        (a[14] * b02 - a[12] * b05 - a[15] * b01) / det,
        (a[8] * b05 - a[10] * b02 + a[11] * b01) / det,
        (a[4] * b10 - a[5] * b08 + a[7] * b06) / det,
        (a[1] * b08 - a[0] * b10 - a[3] * b06) / det,
        (a[12] * b04 - a[13] * b02 + a[15] * b00) / det,
        (a[9] * b02 - a[8] * b04 - a[11] * b00) / det,
        (a[5] * b07 - a[4] * b09 - a[6] * b06) / det,
        (a[0] * b09 - a[1] * b07 + a[2] * b06) / det,
        (a[13] * b01 - a[12] * b03 - a[14] * b00) / det,
        (a[8] * b03 - a[9] * b01 + a[10] * b00) / det,
    ];
}

function rotate4(a, rad, x, y, z) {
    let len = Math.hypot(x, y, z);
    x /= len;
    y /= len;
    z /= len;
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    let t = 1 - c;
    let b00 = x * x * t + c;
    let b01 = y * x * t + z * s;
    let b02 = z * x * t - y * s;
    let b10 = x * y * t - z * s;
    let b11 = y * y * t + c;
    let b12 = z * y * t + x * s;
    let b20 = x * z * t + y * s;
    let b21 = y * z * t - x * s;
    let b22 = z * z * t + c;
    return [
        a[0] * b00 + a[4] * b01 + a[8] * b02,
        a[1] * b00 + a[5] * b01 + a[9] * b02,
        a[2] * b00 + a[6] * b01 + a[10] * b02,
        a[3] * b00 + a[7] * b01 + a[11] * b02,
        a[0] * b10 + a[4] * b11 + a[8] * b12,
        a[1] * b10 + a[5] * b11 + a[9] * b12,
        a[2] * b10 + a[6] * b11 + a[10] * b12,
        a[3] * b10 + a[7] * b11 + a[11] * b12,
        a[0] * b20 + a[4] * b21 + a[8] * b22,
        a[1] * b20 + a[5] * b21 + a[9] * b22,
        a[2] * b20 + a[6] * b21 + a[10] * b22,
        a[3] * b20 + a[7] * b21 + a[11] * b22,
        ...a.slice(12, 16),
    ];
}

function translate4(a, x, y, z) {
    return [
        ...a.slice(0, 12),
        a[0] * x + a[4] * y + a[8] * z + a[12],
        a[1] * x + a[5] * y + a[9] * z + a[13],
        a[2] * x + a[6] * y + a[10] * z + a[14],
        a[3] * x + a[7] * y + a[11] * z + a[15],
    ];
}

function createWorker(self) {
    let buffer;
    let vertexCount = 0;
    let viewProj;
    const rowLength = 3 * 4 + 3 * 4 + 4 * 4 + 4 * 4;
    let lastProj = [];
    let depthIndex = new Uint32Array();
    let lastVertexCount = 0;
    let lastbuffer;

    var _floatView = new Float32Array(1);
    var _int32View = new Int32Array(_floatView.buffer);

    function floatToHalf(float) {
        _floatView[0] = float;
        var f = _int32View[0];

        var sign = (f >> 31) & 0x0001;
        var exp = (f >> 23) & 0x00ff;
        var frac = f & 0x007fffff;

        var newExp;
        if (exp == 0) {
            newExp = 0;
        } else if (exp < 113) {
            newExp = 0;
            frac |= 0x00800000;
            frac = frac >> (113 - exp);
            if (frac & 0x01000000) {
                newExp = 1;
                frac = 0;
            }
        } else if (exp < 142) {
            newExp = exp - 112;
        } else {
            newExp = 31;
            frac = 0;
        }

        return (sign << 15) | (newExp << 10) | (frac >> 13);
    }

    function packHalf2x16(x, y) {
        return (floatToHalf(x) | (floatToHalf(y) << 16)) >>> 0;
    }
   
    function generateTexture() {
        if (!buffer) return;
        //console.log('buffer is', buffer);
        const f_buffer = new Float32Array(buffer);
        var texwidth = 1024 * 8; // Set to your desired width
        //console.log(vertexCount)
        var texheight = Math.ceil((8 * vertexCount) / texwidth); // Set to your desired height
        var texdata_f = new Float32Array(texwidth * texheight * 4);

        // Here we convert from a .splat file buffer into a texture
        // With a little bit more foresight perhaps this texture file
        // should have been the native format as it'd be very easy to
        // load it into webgl.
        for (let i = 0; i < vertexCount; i++) {
            // x, y, z
            texdata_f[32 * i + 0] = f_buffer[14 * i + 0];
            texdata_f[32 * i + 1] = f_buffer[14 * i + 1];
            texdata_f[32 * i + 2] = f_buffer[14 * i + 2];
            

            // r, g, b, a
            texdata_f[32 * i + 10] = f_buffer[14 * i + 6];
            texdata_f[32 * i + 11] = f_buffer[14 * i + 7];
            texdata_f[32 * i + 12] = f_buffer[14 * i + 8];
            texdata_f[32 * i + 13] = f_buffer[14 * i + 9];


            // quaternions
            let scale = [
                f_buffer[14 * i + 3],
                f_buffer[14 * i + 4],
                f_buffer[14 * i + 5],
            ];
            let rot = [
                f_buffer[14 * i + 10],
                f_buffer[14 * i + 11],
                f_buffer[14 * i + 12],
                f_buffer[14 * i + 13],
            ];

            // Compute the matrix product of S and R (M = S * R)
            const M = [
                1.0 - 2.0 * (rot[2] * rot[2] + rot[3] * rot[3]),
                2.0 * (rot[1] * rot[2] + rot[0] * rot[3]),
                2.0 * (rot[1] * rot[3] - rot[0] * rot[2]),

                2.0 * (rot[1] * rot[2] - rot[0] * rot[3]),
                1.0 - 2.0 * (rot[1] * rot[1] + rot[3] * rot[3]),
                2.0 * (rot[2] * rot[3] + rot[0] * rot[1]),

                2.0 * (rot[1] * rot[3] + rot[0] * rot[2]),
                2.0 * (rot[2] * rot[3] - rot[0] * rot[1]),
                1.0 - 2.0 * (rot[1] * rot[1] + rot[2] * rot[2]),
            ].map((k, i) => k * scale[Math.floor(i / 3)]);

            const sigma = [
                M[0] * M[0] + M[3] * M[3] + M[6] * M[6],
                M[0] * M[1] + M[3] * M[4] + M[6] * M[7],
                M[0] * M[2] + M[3] * M[5] + M[6] * M[8],
                M[1] * M[1] + M[4] * M[4] + M[7] * M[7],
                M[1] * M[2] + M[4] * M[5] + M[7] * M[8],
                M[2] * M[2] + M[5] * M[5] + M[8] * M[8],
            ];
            
            texdata_f[32 * i + 4] = 4 * sigma[0];
            texdata_f[32 * i + 5] = 4 * sigma[1];
            texdata_f[32 * i + 6] = 4 * sigma[2];
            texdata_f[32 * i + 7] = 4 * sigma[3];
            texdata_f[32 * i + 8] = 4 * sigma[4];
            texdata_f[32 * i + 9] = 4 * sigma[5];
            /**/

        }
        
        self.postMessage({ texdata_f, texwidth, texheight }, [texdata_f.buffer]);
        
    }
    function runSort(viewProj) {
        if (!buffer) return;
        const f_buffer = new Float32Array(buffer);
        if (lastVertexCount == vertexCount) {
            let dot =
                lastProj[2] * viewProj[2] +
                lastProj[6] * viewProj[6] +
                lastProj[10] * viewProj[10];
            if (Math.abs(dot - 1) < 0.01) {
                return;
            }
        } else {
            generateTexture();
            lastVertexCount = vertexCount;
        }

        //console.time("sort");
        let maxDepth = -Infinity;
        let minDepth = Infinity;
        let sizeList = new Int32Array(vertexCount);
        for (let i = 0; i < vertexCount; i++) {
            let depth =
                ((viewProj[2] * f_buffer[14 * i + 0] +
                    viewProj[6] * f_buffer[14 * i + 1] +
                    viewProj[10] * f_buffer[14 * i + 2]) *
                    4096) |
                0;
            sizeList[i] = depth;
            if (depth > maxDepth) maxDepth = depth;
            if (depth < minDepth) minDepth = depth;
        }

        // This is a 16 bit single-pass counting sort
        let depthInv = (256 * 256) / (maxDepth - minDepth);
        let counts0 = new Uint32Array(256 * 256);
        for (let i = 0; i < vertexCount; i++) {
            sizeList[i] = ((sizeList[i] - minDepth) * depthInv) | 0;
            counts0[sizeList[i]]++;
        }
        let starts0 = new Uint32Array(256 * 256);
        for (let i = 1; i < 256 * 256; i++)
            starts0[i] = starts0[i - 1] + counts0[i - 1];
        depthIndex = new Uint32Array(vertexCount);
        for (let i = 0; i < vertexCount; i++)
            depthIndex[starts0[sizeList[i]]++] = i;


        lastProj = viewProj;
        self.postMessage({ depthIndex, viewProj, vertexCount }, [
            depthIndex.buffer,
        ]);
    }
    const throttledSort = () => {
        if (!sortRunning) {
            sortRunning = true;
            let lastView = viewProj;
            runSort(lastView);
            setTimeout(() => {
                sortRunning = false;
                if (lastView !== viewProj) {
                    throttledSort();
                }
            }, 0);
        }
    };

    let sortRunning;
    self.onmessage = (e) => {
        if (e.data.ply) {
        } else if (e.data.buffer) {
            buffer = e.data.buffer;
            vertexCount = e.data.vertexCount;
        } else if (e.data.vertexCount) {
            vertexCount = e.data.vertexCount;
        } else if (e.data.view) {
            viewProj = e.data.view;
            throttledSort();
        }
    };
}

const vertexShaderSource = `
#version 300 es
precision highp float;

uniform highp sampler2D u_texture;
uniform mat4 projection, view;
uniform vec2 focal;
uniform vec2 viewport;
uniform vec3 sceneCenter;
uniform vec3 cameraPosition;


in vec2 position;
in int index;

out vec4 vColor;
out vec2 vPosition;

void main () {
    const float SH_C0 = 0.28209479177387814f;
    
    vec4 cen = texelFetch(u_texture, ivec2((uint(index) & 0x3ffu) << 3, uint(index) >> 10), 0); 
    //vec4 cam = view * vec4(uintBitsToFloat(cen.xyz), 1); //uintBitsToFloat(cen.xyz) -> splatcenter
    vec4 cam = view * vec4(cen.xyz, 1); 
    vec4 pos2d = projection * cam;  //pos2d -> clipcenter


    float clip = 1.2 * pos2d.w;
    if (pos2d.z < -clip || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip) {
        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
        return;
    }
    
    vec4 cov = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 3) | 1u, uint(index) >> 10), 0);
    vec4 cov_1 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 3) | 2u, uint(index) >> 10), 0);
    vec2 u1 = cov.xy;
    vec2 u2 = cov.zw; 
    vec2 u3 = cov_1.xy;

    mat3 Vrk = mat3(u1.x, u1.y, u2.x, u1.y, u2.y, u3.x, u2.x, u3.x, u3.y);

    mat3 J = mat3(
        focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), 
        0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), 
        0., 0., 0.
    );

    mat3 T = transpose(mat3(view)) * J;
    mat3 cov2d = transpose(T) * Vrk * T;
    cov2d[0][0] += 0.3;
	cov2d[1][1] += 0.3; 

    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
    float lambda1 = mid + radius, lambda2 = mid - radius;

    if(lambda2 < 0.0) return;
    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

    vec3 worldViewDir = normalize(cen.xyz - cameraPosition);
    //vec3 worldViewDir = cen.xyz;
    float x = worldViewDir.x;
    float y = worldViewDir.y;
    float z = worldViewDir.z;


    vec4 base_color_2 = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 3) | 3u, uint(index) >> 10), 0);
    vColor = vec4(SH_C0 * cov_1.z, SH_C0 * cov_1.w, SH_C0 * base_color_2.r, base_color_2.g);
    vColor += vec4(0.5,0.5,0.5,0.0);

    vPosition = position.xy;

    vec2 vCenter = vec2(pos2d) / pos2d.w;
    gl_Position = vec4(
        vCenter 
        + position.x * majorAxis / viewport 
        + position.y * minorAxis / viewport, 0.0, 1.0);

}
`.trim();

const fragmentShaderSource = `
#version 300 es
precision highp float;

in vec4 vColor;
in vec2 vPosition;

out vec4 fragColor;

void main () {
    
    float A = -dot(vPosition, vPosition);
    if (A < -4.0) discard;
    vec3 color = vColor.rgb;
    float opacity = exp(A) * vColor.a;
    fragColor = vec4(opacity * color.rgb, opacity);
}
`.trim();
function mergeArray(array1,array2){
    const mergedArray = new Uint8Array(array1.length+array2.length);
    mergedArray.set(array1,0);
    mergedArray.set(array2,array1.length);
    return mergedArray
}


function sequence_worker(self){
    this.ave_time = [];
    this.lastproj = null;
    this.full_dict = null;
    this.keys = null;
    this.fx = 0;
    this.fy = 0;
    this.width = 0;
    this.height = 0;
    this.level = null;
    this.viewMatrix = null;
    this.port = null;
    function multiply_coord(coord,proj){
        return [
           coord[0]*proj[0]+coord[1]*proj[4]+coord[2]*proj[8]+proj[12],
           coord[0]*proj[1]+coord[1]*proj[5]+coord[2]*proj[9]+proj[13],
           coord[0]*proj[2]+coord[1]*proj[6]+coord[2]*proj[10]+proj[14],
           
        ] 
    }
    function focal2fov(focal, pixel) {
        return 2 * Math.atan(pixel / (2 * focal));
    }
    function point_triangle(A, B, C, P){
        let flag;
        function barycentric_coordinates(A, B, C, P){
            let detT = (B[1] - C[1]) * (A[0] - C[0]) + (C[0] - B[0]) * (A[1] - C[1])
            let alpha = ((B[1] - C[1]) * (P[0] - C[0]) + (C[0] - B[0]) * (P[1] - C[1])) / detT
            let beta = ((C[1] - A[1]) * (P[0] - C[0]) + (A[0] - C[0]) * (P[1] - C[1])) / detT
            let gamma = 1 - alpha - beta
            if(alpha > 0 && alpha < 1 && beta > 0 && beta < 1 && gamma > 0 && gamma < 1){
                flag = true;
            }
            else{
                flag = false;
            }
            return flag;
        }
        
        return barycentric_coordinates(A, B, C, P)
    }
    function point_in_AABB(point,AABB){
        let flag;
        if(point[0] > AABB[0] && point[0] < AABB[1] && point[1] > AABB[2] && point[1] < AABB[3]){
            flag = true;
        }else{
            flag = false;
        }
        return flag;
    }

    function edgeIntersect(e1, e2) {
        let [p1, p2] = e1;
        let [p3, p4] = e2;
        let [x1, y1] = p1;
        let [x2, y2] = p2;
        let [x3, y3] = p3;
        let [x4, y4] = p4;
        let flag = true;
        
        let denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (denom === 0) { // Check for parallel lines
            flag = false;
        }

        let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
        if (ua <= 0 || ua >= 1) { // Check if intersection is out of bounds for the first line segment
            flag = false;
        }

        let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
        if (ub <= 0 || ub >= 1) { // Check if intersection is out of bounds for the second line segment
            flag = false;
        }
        return flag;
    }

    function createTriangle(p1, p2, p3) {
        let vertices = [p1, p2, p3];
        let edges = [[p1, p2], [p1, p3], [p2, p3]];
        return { vertices, edges };
    }

    function createQuad(v1, v2, v3, v4) {
        // v1: left top, v2: right top, v3: left bottom, v4: right bottom
        let vertices = [v1, v2, v3, v4];
        let edges = [[v1, v2], [v2, v4], [v4, v3], [v3, v1]];
        return { vertices, edges };
    }
    
    function createCube(leftBottom, rightTop) {
        let v6 = leftBottom;
        let v0 = rightTop;

        let v1 = [v0[0], v6[1], v0[2]];
        let v2 = [v6[0], v6[1], v0[2]];
        let v3 = [v6[0], v0[1], v0[2]];
        let v4 = [v0[0], v0[1], v6[2]];
        let v5 = [v0[0], v6[1], v6[2]];
        let v7 = [v6[0], v0[1], v6[2]];


        let vertices = [v0, v1, v2, v3, v4, v5, v6, v7];
        return vertices;
    }

    function buildEdges(v) {
        let edges = [
            [v[0], v[1]],
            [v[0], v[3]],
            [v[0], v[4]],
            [v[1], v[2]],
            [v[1], v[5]],
            [v[2], v[3]],
            [v[2], v[6]],
            [v[3], v[7]],
            [v[4], v[5]],
            [v[4], v[7]],
            [v[5], v[6]],
            [v[6], v[7]]
        ];
        return edges;
    }
    function xy_Projection(w2cV) {
        // Project each vertex onto the XY plane
        let vertices = w2cV.map(v => [v[0], v[1]]);
    
        // Assuming buildEdge is a function that creates edges from the vertices
        let edges = buildEdges(vertices);
    
        return { vertices, edges };
    }
    function pyramidBoundary(fx, fy, width, height, zfar) {

        let fovx = focal2fov(fx, width);
        let halfH = Math.abs(zfar) * Math.tan(fovx * 0.5);
    
        let fovy = focal2fov(fy, height);
        let halfV = Math.abs(zfar) * Math.tan(fovy * 0.5);
    
        return [halfV, halfH];
    }
    function xz_Projection(w2cV) {
        // Project each vertex onto the XY plane
        let vertices = w2cV.map(v => [v[0], v[2]]);
    
        // Assuming buildEdge is a function that creates edges from the vertices
        let edges = buildEdges(vertices);
    
        return { vertices, edges };
    }

    function yz_Projection(w2cV) {
        // Project each vertex onto the XY plane
        let vertices = w2cV.map(v => [v[2], v[1]]);
        // Assuming buildEdge is a function that creates edges from the vertices
        let edges = buildEdges(vertices);
    
        return { vertices, edges };
    }
    function triangle_intersect(triangle,proj_v){
        let tri_vertices = triangle.vertices;
        let proj_v_vertices = proj_v.vertices;
        let tri_edges = triangle.edges
        let proj_v_edges = proj_v.edges
        let flag = false;
        for (let q_v of proj_v_vertices) {
            if (point_triangle(tri_vertices[0], tri_vertices[1], tri_vertices[2], q_v)) {
                flag = true;
            }
        }
    
        for (let q_e of proj_v_edges) {
            for (let t_e of tri_edges) {
                if (edgeIntersect(q_e, t_e)) {
                    flag = true;
                }
            }
        }
        return flag; 
            
    }

    function quadIntersect(quad2, quad1) {
        let quadVertices = quad1.vertices;
        let quadEdges = quad1.edges;
        let camquadVertices = quad2.vertices;
        let camquadEdges = quad2.edges;
        let flag = false;
        let camAABB = [camquadVertices[2][0], camquadVertices[1][0], camquadVertices[2][1], camquadVertices[1][1]];
        
        for (let q_v of quadVertices) {
            if (point_in_AABB(q_v, camAABB)) {
                flag = true;
            }
        }
    
        for (let q_e of quadEdges) {
            for (let cq_e of camquadEdges) {
                if (edgeIntersect(q_e, cq_e)) {
                    flag = true;
                }
            }
        }
        return flag;
    }
    function pyramidIntersect(tri1, tri2, rect, w2cVertices) {
        let xyProj = xy_Projection(w2cVertices);
        let yzProj = yz_Projection(w2cVertices);
        let xzProj = xz_Projection(w2cVertices);
        
        if (triangle_intersect(tri2, yzProj) && triangle_intersect(tri1, xzProj) && quadIntersect(rect, xyProj)) {
            return true;
        } else {
            return false;
        }
        
    }
    function multiplyMatrixVector(coord, proj) {
        return [
            coord[0]*proj[0]+coord[1]*proj[4]+coord[2]*proj[8]+proj[12],
            coord[0]*proj[1]+coord[1]*proj[5]+coord[2]*proj[9]+proj[13],
            coord[0]*proj[2]+coord[1]*proj[6]+coord[2]*proj[10]+proj[14],
            coord[0]*proj[3]+coord[1]*proj[7]+coord[2]*proj[11]+proj[15],
         ] 
    }
    
    function projectToScreen(vertex, viewProj, viewport) {
        // Here we only use the viewMatrix for projection, assuming no additional transformations
        const projectionMatrix = viewProj;
    
        // Apply the view (projection) matrix to the vertex
        const clipSpace = multiplyMatrixVector([...vertex, 1], projectionMatrix);
    
        // Perspective division to get NDC (Normalized Device Coordinates)
        const ndc = clipSpace.map(v => v / clipSpace[3]);
    
        // Convert NDC to screen space
        const [width, height] = viewport;
        const screenX = (ndc[0] * 0.5 + 0.5) * width;
        const screenY = (ndc[1] * 0.5 + 0.5) * height;
    
        return [screenX, screenY];
    }
    
    // Function to calculate the visibility factor of a cube
    function clipToViewport(x, y, viewportBoundary) {
        x = Math.max(viewportBoundary.left, Math.min(x, viewportBoundary.right));
        y = Math.max(viewportBoundary.top, Math.min(y, viewportBoundary.bottom));
        return [x, y];
    }

    function calculateVisibilityFactor(vertices, viewProj, viewport) {
        // Create an offscreen canvas
        const [width, height] = viewport;
        const viewportBoundary = {
            left: 0,
            right: width,
            top: 0,
            bottom: height
        };

        const offScreenCanvas = new OffscreenCanvas(width, height);
        const context = offScreenCanvas.getContext('2d');
    
        // Clear the off-screen canvas
        context.clearRect(0, 0, width, height);
    
        // Project vertices using the provided viewMatrix
        const projectedVertices = vertices.map(v => projectToScreen(v, viewProj, viewport));
    
        // Define cube faces
        const faces = [
            [0, 1, 3, 2], // Front face
            [4, 5, 7, 6], // Back face
            [0, 1, 5, 4], // Bottom face
            [2, 3, 7, 6], // Top face
            [0, 2, 6, 4], // Left face
            [1, 3, 7, 5]  // Right face
        ];
    
        faces.forEach(face => {
            let visibleVertices = [];
    
            // Clip each vertex to the viewport
            face.forEach(index => {
                let [x, y] = projectedVertices[index];
                // Check if the vertex is inside the viewport
                if (x >= viewportBoundary.left && x <= viewportBoundary.right &&
                    y >= viewportBoundary.top && y <= viewportBoundary.bottom) {
                    visibleVertices.push([x, y]);
                } else {
                    // Clip the vertex to the viewport
                    visibleVertices.push(clipToViewport(x, y, viewportBoundary));
                }
            });
    
            if (visibleVertices.length > 1) {
                context.beginPath();
                visibleVertices.forEach(([x, y], i) => {
                    if (i === 0) context.moveTo(x, y);
                    else context.lineTo(x, y);
                });
                context.closePath(); // Close the shape with the viewport boundary
                context.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Semi-transparent color
                context.fill();
            }
        });
        const imageData = context.getImageData(0, 0, width, height).data;
        let coveredPixels = 0;
        for (let i = 0; i < imageData.length; i += 4) {
            if (imageData[i + 3] > 0) coveredPixels++;
        }
        const totalPixels = width * height;
        const visibilityFactor = coveredPixels / totalPixels;
    
        return visibilityFactor;
    }
    
    this.calculating = false;
    
    function get_voxel_list(viewMatrix,fx,fy,width,height,zfar,viewProj){
        
        let required_dict = {};
        let z_depth = [];
        
        quad_boundary = pyramidBoundary(fx,fy,width,height,zfar);
        half_H = quad_boundary[1];
        half_V = quad_boundary[0];

        tri1 = createTriangle([0,0],[-half_H,zfar],[half_H,zfar]);
        tri2 = createTriangle([0,0],[zfar,half_V],[zfar,-half_V]);
        rect = createQuad([-half_H,half_V],[half_H,half_V],[-half_H,-half_V],[half_H,-half_V]);


        function uv_project(point){
           point_cam = multiply_coord(point,viewMatrix); 
           return point_cam;
        }
        
        function sorted_array(arr, z_value) {
            let index = 0;
            if (arr.length == 0) {
                arr.push(z_value);
                return [arr, index];
            }
            // Modify the condition to insert in descending order
            while (index < arr.length && arr[index] > z_value) {
                index++;
            }
            arr.splice(index, 0, z_value);
            return [arr, index];
        }
        
        for(let key_num in this.keys){
            voxel_name = this.keys[key_num]
            leftBottom = this.full_dict[voxel_name]['leftBottom'];
            rightTop = this.full_dict[voxel_name]['rightTop'];
            

            vertices = createCube(leftBottom,rightTop);
            world_vertices = []
            for(let v of vertices){
                v_cam = uv_project(v);
                world_vertices.push(v_cam);
            }

            if(pyramidIntersect(tri1, tri2, rect, world_vertices)){
                required_dict[voxel_name] = {};
                let density = this.full_dict[voxel_name]['density'];
                if (density < 10){
                    required_dict[voxel_name]['priority'] = "low"
                }
                else{
                    let center = [(leftBottom[0]+rightTop[0])/2, (leftBottom[1]+rightTop[1])/2, (leftBottom[2]+rightTop[2])/2];
                    let center2cam = uv_project(center);
                    let z = center2cam[2];
                    
                    let z_value = Math.abs(z);

                    let visibilityFactor = calculateVisibilityFactor(vertices, viewProj, [width, height]);
                    
                    let score = Math.log10(density * visibilityFactor / (z_value+0.00001))
                    
                    
                    if (score > 0){
                        required_dict[voxel_name]['priority'] = 'high'
                        
                    }else{
                        required_dict[voxel_name]['priority'] = "low"
                        
                    }

                }
                
            }
            
        }
        return required_dict;
    }
    self.onmessage = (e) => {
        if(e.data.full_dict){
            this.full_dict = e.data.full_dict;
            this.keys = Object.keys(this.full_dict);
            this.fx = e.data.fx;
            this.fy = e.data.fy;
            this.width = e.data.width;
            this.height = e.data.height;

        }else if(e.data.port){
            this.port = e.data.port;
        }
        else{
            if(this.calculating){
                console.log(this.calculating)
                return;
            }
            else{
                viewMatrix = e.data.viewMatrix;
                    let viewProj = e.data.proj;
                    
                    if(this.lastproj){
                        let dot =
                        this.lastproj[2] * viewMatrix[2] +
                        this.lastproj[6] * viewMatrix[6] +
                        this.lastproj[10] * viewMatrix[10];
                        if (Math.abs(dot - 1) < 0.01) {
                            return;
                        }

                    }

                    self.postMessage({ block: 1 });
                    required_dict = get_voxel_list(viewMatrix,this.fx,this.fy,this.width,this.height,1000, viewProj);
                    self.postMessage({ block: 2 });      
                    this.lastproj = viewMatrix;
                    this.port.postMessage({required_voxels:required_dict});
                    this.calculating = false;
         
            }

        }
       
    };

}

function url_worker(self){
	let scene_name = 'truck'
    let root = 'https://localhost:8081/assets/data/'+scene_name+'/voxels_new/';
    let all_voxels;
    let downloader;
    let downloading_voxels = {};
    let downloaded_voxels = [];

    
    
    function remove_existing_voxels(downloaded_voxels, voxel_list){
        return voxel_list.filter(item => !downloaded_voxels.includes(item));
    }
    function init_downloader(voxels){
        const init_download = {}
        for(let voxel of voxels){
            init_download[voxel] = {};
            init_download[voxel]['downloadedbytes'] = 0;

        }
        return init_download;
    }
    function get_voxels_to_download(required_voxels, downloaded_voxels) {
        let voxels_to_download = {};
        for (let key in required_voxels) {
            if (!(key in downloaded_voxels)) {
                voxels_to_download[key] = required_voxels[key];
            }
        }
        
        return voxels_to_download;
    }
    
    
    function generate_urls(queue, root) {
        let urls = {};
        for (let voxel in queue) {
            let priority = queue[voxel].priority;
            let voxel_path = `${voxel}.ply`;
            let url = new URL(voxel_path, root);
            urls[voxel] = {
                url: url,
                priority: priority
            };
        }
        
        return urls;
    }
    
    let downloadLocks = {}; 


    async function fetchDataFromUrl(url, key, priority) {
        if (downloaded_voxels.includes(key)) {
            console.log(`Voxel ${key} is already fully downloaded.`);
            return;
        }
    
        if (downloadLocks[key]) {
            console.log(`Voxel ${key} is already locked for download. Skipping duplicate request.`);
            return;
        }
    
        downloadLocks[key] = true;
    
        if (downloading_voxels[key]) {
            const currentPriority = downloading_voxels[key]['priority'];
            
            console.log(`Current priority: ${currentPriority}, New priority: ${priority}`);
            if (currentPriority === priority) {
                console.log(`Voxel ${key} is already being downloaded with the same priority.`);
                delete downloadLocks[key]; // Unlock the voxel after processing
                return;
            }

            console.log(`Voxel ${key} priority changed, aborting current download and restarting with new priority.`);
            downloading_voxels[key]['controller'].abort(); // Abort current download
            delete downloading_voxels[key]; // Clear the current download status
        }

        const controller = new AbortController();
        downloading_voxels[key] = { priority, controller };
    
        try {
            console.log(`Starting download for voxel ${key} with priority ${priority}.`);
            const response = await fetch(url, {
                signal: controller.signal, // Use the AbortController signal
                priority:priority,
                mode: "cors",
                credentials: "omit",
                headers: {
                    'Range': `bytes=${downloader[key]["downloadedbytes"]}-`, // Continue from where the last download stopped
                }
            });
    
            const reader = response.body.getReader();
            while (true) {
                const { done, value } = await reader.read();
                if (!downloading_voxels[key]) {
                    console.log(`Download for voxel ${key} was aborted.`);
                    reader.cancel();
                    break;
                }
    
                if (done) {
                    downloaded_voxels.push(key);
                    delete downloading_voxels[key]; // Mark the voxel as fully downloaded
                    console.log(`Download for voxel ${key} completed.`);
                    break;
                }
                self.postMessage({
                    value: value,
                    voxel: key,
                });
    
                downloader[key]["downloadedbytes"] += value.length;
                console.log(`Downloaded ${downloader[key]["downloadedbytes"]} bytes for voxel ${key}.`);
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log(`Download for voxel ${key} was aborted due to priority change.`);
            } else {
                console.error(`Error downloading voxel ${key}:`, error);
            }
            delete downloading_voxels[key]; // Clear the downloading status on error
        } finally {
            delete downloadLocks[key];
        }
    }
    

    function handleMultipleUrls(urls) {
        Object.entries(urls).forEach(([key, { url, priority }]) => {
            fetchDataFromUrl(url, key, priority);
        });
    }
    self.onmessage = (e) => {
        if(e.data.list){
        }else if(e.data.full_list){
            all_voxels = e.data.full_list
            downloader = init_downloader(all_voxels)
        }else if(e.data.port){
            const port = e.data.port;
            port.onmessage = (event) => {
                if (event.data.required_voxels){
                    required_voxels = event.data.required_voxels;
                    let rest = remove_existing_voxels(downloaded_voxels,all_voxels);
                    
                    if(rest.length == 0){
                        self.postMessage({
                            done:true
                        })
                    }
                    urls = generate_urls(required_voxels, root);
                    handleMultipleUrls(urls);

                }
            }
        }
    }

}

function saveCanvasAsPNG(canvas, filename) {
    // Create a new canvas without the alpha channel
    const newCanvas = document.createElement('canvas');
    newCanvas.width = canvas.width;
    newCanvas.height = canvas.height;
    
    const newContext = newCanvas.getContext('2d');
    
    // Fill the new canvas with black (your desired background color)
    newContext.fillStyle = 'black';
    newContext.fillRect(0, 0, newCanvas.width, newCanvas.height);
    
    // Draw the original canvas onto the new canvas
    newContext.drawImage(canvas, 0, 0);
    
    // Convert to PNG and save the file
    const dataURL = newCanvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = dataURL;
    a.download = filename;
    a.click();
}
function init_startpoints(voxels){
    const init_start = {}
    for(let voxel of voxels){
        init_start[voxel] = {};
        init_start[voxel]['breakpoint'] = 0;

    }
    return init_start;
}

async function main() {
	let scene_name = 'truck'
    const cam_url = new URL("https://localhost:8081/assets/data/"+scene_name+"/smooth_camera_trace.json");
    const cam_req = await fetch(cam_url);
    if(cam_req.status != 200) throw new Error(cam_req.status + " Unable to load " + cam_req.url);
    let cameras = await cam_req.json();
    let camera = cameras[0];
    let downloaded_voxels = [];
    let lastVertexCount = -1;
    

    let defaultViewMatrix = getViewMatrix(camera);
    let viewMatrix = defaultViewMatrix;

    let carousel = false;
    const params = new URLSearchParams(location.search);
    try {
        viewMatrix = JSON.parse(decodeURIComponent(location.hash.slice(1)));
        carousel = false;
    } catch (err) {}
    const voxel_url = new URL("https://localhost:8081/assets/data/"+scene_name+"/voxels_new/voxel_new.json");
    const voxel_list_req = await fetch(voxel_url);
    if(voxel_list_req.status != 200) throw new Error(voxel_list_req.status + " Unable to load " + voxel_list_req.url);
    voxel_dict = await voxel_list_req.json();
    let all_voxels = [];
    let total_length;
    for(let key of Object.keys(voxel_dict)){ 
        if(key == 'length'){
            total_length = voxel_dict['length'];
            delete voxel_dict['length'];
        }
        else{
            all_voxels.push(key)
        }    
    }
    //console.log(all_voxels.length)
    let download_maneger = init_startpoints(all_voxels)

    let all_done = false;   
    
    const rowLength = 3 * 4 + 3 * 4 + 4 * 4 + 4 * 4;

    const downsample = 1

    const download_worker = new Worker(
        URL.createObjectURL(
            new Blob(["(", url_worker.toString(), ")(self)"], {
                type: "application/javascript",
            }),
        ),

    );
    download_worker.postMessage({
        full_list:all_voxels
    })

    const worker = new Worker(
        URL.createObjectURL(
            new Blob(["(", createWorker.toString(), ")(self)"], {
                type: "application/javascript",
            }),
        ),
    );
    const list_worker = new Worker(
        URL.createObjectURL(
            new Blob(["(", sequence_worker.toString(), ")(self)"], {
                type: "application/javascript",
            }),
        ),
    );
    const channel = new MessageChannel();

    // Send port2 to worker2 so it can communicate with worker1
    list_worker.postMessage({ port: channel.port2 }, [channel.port2]);

    // Send the MessageChannel's port1 to worker1
    download_worker.postMessage({ port: channel.port1 }, [channel.port1]);

    list_worker.postMessage({
        full_dict:voxel_dict,
        fx : camera.fx,
        fy : camera.fy,
        width : camera.width,
        height : camera.height,
        viewMatrix:viewMatrix
    });

    

    const canvas = document.getElementById("canvas");
    const fps = document.getElementById("fps");
    const camid = document.getElementById("camid");
    const d_length = document.getElementById("downloaded_voxels");

    let projectionMatrix;
    

    const gl = canvas.getContext("webgl2", {
        antialias: false,
    });

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(vertexShader));

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(fragmentShader));

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(program));

    gl.disable(gl.DEPTH_TEST); // Disable depth testing

    // Enable blending
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(
        gl.ONE_MINUS_DST_ALPHA,
        gl.ONE,
        gl.ONE_MINUS_DST_ALPHA,
        gl.ONE,
    );
    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);

    const u_projection = gl.getUniformLocation(program, "projection");
    const u_viewport = gl.getUniformLocation(program, "viewport");
    const u_focal = gl.getUniformLocation(program, "focal");
    const u_view = gl.getUniformLocation(program, "view");

    // positions
    const triangleVertices = new Float32Array([-2, -2, 2, -2, 2, 2, -2, 2]);
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, triangleVertices, gl.STATIC_DRAW);
    const a_position = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(a_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    var u_textureLocation = gl.getUniformLocation(program, "u_texture");
    gl.uniform1i(u_textureLocation, 0);

    const indexBuffer = gl.createBuffer();
    const a_index = gl.getAttribLocation(program, "index");
    gl.enableVertexAttribArray(a_index);
    gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
    gl.vertexAttribIPointer(a_index, 1, gl.INT, false, 0, 0);
    gl.vertexAttribDivisor(a_index, 1);

    const resize = () => {
        gl.uniform2fv(u_focal, new Float32Array([camera.fx, camera.fy]));

        projectionMatrix = getProjectionMatrix(
            camera.fx,
            camera.fy,
            camera.width,
            camera.height
            //camera.width,
            //camera.height,
        );
        gl.uniform2fv(u_viewport, new Float32Array([camera.width, camera.height]));
        gl.canvas.width = camera.width;
        gl.canvas.height = camera.height;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.uniformMatrix4fv(u_projection, false, projectionMatrix);
    };

    window.addEventListener("resize", resize);
    resize();
    console.log(projectionMatrix);
    const splatData = new Uint8Array(total_length);
    worker.onmessage = (e) => {
        if (e.data.buffer) {
            splatData = new Uint8Array(e.data.buffer);
            const blob = new Blob([splatData.buffer], {
                type: "application/octet-stream",
            });
            const link = document.createElement("a");
            link.download = "model.splat";
            link.href = URL.createObjectURL(blob);
            document.body.appendChild(link);
            link.click();
        } else if (e.data.texdata_f) {
            const { texdata_f, texwidth, texheight } = e.data;
            //console.log("texdata is ",texdata);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_S,
                gl.CLAMP_TO_EDGE,
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_T,
                gl.CLAMP_TO_EDGE,
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA32F,
                texwidth,
                texheight,
                0,
                gl.RGBA,
                gl.FLOAT,
                texdata_f
            );
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
        } else if (e.data.depthIndex) {
            const { depthIndex, viewProj } = e.data;
            //console.log("depthIndex", depthIndex)
            gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, depthIndex, gl.DYNAMIC_DRAW);
            vertexCount = e.data.vertexCount;
            if ((all_done == true) && (vertexCount > lastVertexCount)){
                worker.postMessage({
                    buffer: splatData.buffer,
                    vertexCount: Math.floor(bytesRead / rowLength),
                });
                lastVertexCount = vertexCount;
            }
            
        }
    };


    let activeKeys = [];
	let currentCameraIndex = 0;

    window.addEventListener("keydown", (e) => {
        // if (document.activeElement != document.body) return;
        carousel = false;
        if (!activeKeys.includes(e.code)) activeKeys.push(e.code);
        if (/\d/.test(e.key)) {
            currentCameraIndex = parseInt(e.key)
            camera = cameras[currentCameraIndex];
            viewMatrix = getViewMatrix(camera);
        }
		if (['-', '_'].includes(e.key)){
			currentCameraIndex = (currentCameraIndex + cameras.length - 1) % cameras.length;
			viewMatrix = getViewMatrix(cameras[currentCameraIndex]);
		}
		if (['+', '='].includes(e.key)){
			currentCameraIndex = (currentCameraIndex + 1) % cameras.length;
			viewMatrix = getViewMatrix(cameras[currentCameraIndex]);
		}
        camid.innerText = "cam  " + currentCameraIndex;
        if (e.code == "KeyV") {
            location.hash =
                "#" +
                JSON.stringify(
                    viewMatrix.map((k) => Math.round(k * 100) / 100),
                );
                camid.innerText =""
        } else if (e.code === "KeyP") {
            carousel = true;
            camid.innerText =""
        }
    });
    window.addEventListener("keyup", (e) => {
        activeKeys = activeKeys.filter((k) => k !== e.code);
    });
    window.addEventListener("blur", () => {
        activeKeys = [];
    });

    window.addEventListener(
        "wheel",
        (e) => {
            carousel = false;
            e.preventDefault();
            const lineHeight = 10;
            const scale =
                e.deltaMode == 1
                    ? lineHeight
                    : e.deltaMode == 2
                    ? innerHeight
                    : 1;
            let inv = invert4(viewMatrix);
            if (e.shiftKey) {
                inv = translate4(
                    inv,
                    (e.deltaX * scale) / innerWidth,
                    (e.deltaY * scale) / innerHeight,
                    0,
                );
            } else if (e.ctrlKey || e.metaKey) {
                inv = translate4(
                    inv,
                    0,
                    0,
                    (-10 * (e.deltaY * scale)) / innerHeight,
                );
                // inv[13] = preY;
            } else {
                let d = 4;
                inv = translate4(inv, 0, 0, d);
                inv = rotate4(inv, -(e.deltaX * scale) / innerWidth, 0, 1, 0);
                inv = rotate4(inv, (e.deltaY * scale) / innerHeight, 1, 0, 0);
                inv = translate4(inv, 0, 0, -d);
            }

            viewMatrix = invert4(inv);
        },
        { passive: false },
    );

    let startX, startY, down;
    canvas.addEventListener("mousedown", (e) => {
        carousel = false;
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        down = e.ctrlKey || e.metaKey ? 2 : 1;
    });
    canvas.addEventListener("contextmenu", (e) => {
        carousel = false;
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        down = 2;
    });

    canvas.addEventListener("mousemove", (e) => {
        e.preventDefault();
        if (down == 1) {
            let inv = invert4(viewMatrix);
            let dx = (5 * (e.clientX - startX)) / innerWidth;
            let dy = (5 * (e.clientY - startY)) / innerHeight;
            let d = 4;

            inv = translate4(inv, 0, 0, d);
            inv = rotate4(inv, dx, 0, 1, 0);
            inv = rotate4(inv, -dy, 1, 0, 0);
            inv = translate4(inv, 0, 0, -d);
            viewMatrix = invert4(inv);

            startX = e.clientX;
            startY = e.clientY;
        } else if (down == 2) {
            let inv = invert4(viewMatrix);
            // inv = rotateY(inv, );
            // let preY = inv[13];
            inv = translate4(
                inv,
                (-10 * (e.clientX - startX)) / innerWidth,
                0,
                (10 * (e.clientY - startY)) / innerHeight,
            );
            // inv[13] = preY;
            viewMatrix = invert4(inv);

            startX = e.clientX;
            startY = e.clientY;
        }
    });
    canvas.addEventListener("mouseup", (e) => {
        e.preventDefault();
        down = false;
        startX = 0;
        startY = 0;
    });

    let altX = 0,
        altY = 0;
    canvas.addEventListener(
        "touchstart",
        (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                carousel = false;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                down = 1;
            } else if (e.touches.length === 2) {
                // console.log('beep')
                carousel = false;
                startX = e.touches[0].clientX;
                altX = e.touches[1].clientX;
                startY = e.touches[0].clientY;
                altY = e.touches[1].clientY;
                down = 1;
            }
        },
        { passive: false },
    );
    canvas.addEventListener(
        "touchmove",
        (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && down) {
                let inv = invert4(viewMatrix);
                let dx = (4 * (e.touches[0].clientX - startX)) / innerWidth;
                let dy = (4 * (e.touches[0].clientY - startY)) / innerHeight;

                let d = 4;
                inv = translate4(inv, 0, 0, d);
                // inv = translate4(inv,  -x, -y, -z);
                // inv = translate4(inv,  x, y, z);
                inv = rotate4(inv, dx, 0, 1, 0);
                inv = rotate4(inv, -dy, 1, 0, 0);
                inv = translate4(inv, 0, 0, -d);

                viewMatrix = invert4(inv);

                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // alert('beep')
                const dtheta =
                    Math.atan2(startY - altY, startX - altX) -
                    Math.atan2(
                        e.touches[0].clientY - e.touches[1].clientY,
                        e.touches[0].clientX - e.touches[1].clientX,
                    );
                const dscale =
                    Math.hypot(startX - altX, startY - altY) /
                    Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY,
                    );
                const dx =
                    (e.touches[0].clientX +
                        e.touches[1].clientX -
                        (startX + altX)) /
                    2;
                const dy =
                    (e.touches[0].clientY +
                        e.touches[1].clientY -
                        (startY + altY)) /
                    2;
                let inv = invert4(viewMatrix);
                // inv = translate4(inv,  0, 0, d);
                inv = rotate4(inv, dtheta, 0, 0, 1);

                inv = translate4(inv, -dx / innerWidth, -dy / innerHeight, 0);

                // let preY = inv[13];
                inv = translate4(inv, 0, 0, 3 * (1 - dscale));
                // inv[13] = preY;

                viewMatrix = invert4(inv);

                startX = e.touches[0].clientX;
                altX = e.touches[1].clientX;
                startY = e.touches[0].clientY;
                altY = e.touches[1].clientY;
            }
        },
        { passive: false },
    );
    canvas.addEventListener(
        "touchend",
        (e) => {
            e.preventDefault();
            down = false;
            startX = 0;
            startY = 0;
        },
        { passive: false },
    );

    let jumpDelta = 0;
    let vertexCount = 0;
    let total_vertexcount = 0;

    let lastFrame = 0;
    let avgFps = 0;
    let start = 0;

    window.addEventListener("gamepadconnected", (e) => {
        const gp = navigator.getGamepads()[e.gamepad.index];
        console.log(
            `Gamepad connected at index ${gp.index}: ${gp.id}. It has ${gp.buttons.length} buttons and ${gp.axes.length} axes.`,
        );
    });
    window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Gamepad disconnected");
    });

    let leftGamepadTrigger, rightGamepadTrigger;
    let render_frame = 0;
    let blocker = false;
    

    const frame = (now) => {
        
        let camid = render_frame;
        if(Math.floor(camid / 120) >= 40){
            camid = 4799; 
        }
        let camera = cameras[camid];
        viewMatrix = getViewMatrix(camera);
        
        
        let inv = invert4(viewMatrix);
        let shiftKey = activeKeys.includes("Shift") || activeKeys.includes("ShiftLeft") || activeKeys.includes("ShiftRight")

        if (activeKeys.includes("ArrowUp")) {
            if (shiftKey) {
                inv = translate4(inv, 0, -0.03, 0);
            } else {
                inv = translate4(inv, 0, 0, 0.1);
            }
        }
        if (activeKeys.includes("ArrowDown")) {
            if (shiftKey) {
                inv = translate4(inv, 0, 0.03, 0);
            } else {
                inv = translate4(inv, 0, 0, -0.1);
            }
        }
        if (activeKeys.includes("ArrowLeft"))
            inv = translate4(inv, -0.03, 0, 0);
        //
        if (activeKeys.includes("ArrowRight"))
            inv = translate4(inv, 0.03, 0, 0);
        // inv = rotate4(inv, 0.01, 0, 1, 0);
        if (activeKeys.includes("KeyA")) inv = rotate4(inv, -0.01, 0, 1, 0);
        if (activeKeys.includes("KeyD")) inv = rotate4(inv, 0.01, 0, 1, 0);
        if (activeKeys.includes("KeyQ")) inv = rotate4(inv, 0.01, 0, 0, 1);
        if (activeKeys.includes("KeyE")) inv = rotate4(inv, -0.01, 0, 0, 1);
        if (activeKeys.includes("KeyW")) inv = rotate4(inv, 0.005, 1, 0, 0);
        if (activeKeys.includes("KeyS")) inv = rotate4(inv, -0.005, 1, 0, 0);

        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        let isJumping = activeKeys.includes("Space");
        for (let gamepad of gamepads) {
            if (!gamepad) continue;

            const axisThreshold = 0.1; // Threshold to detect when the axis is intentionally moved
            const moveSpeed = 0.06;
            const rotateSpeed = 0.02;

            // Assuming the left stick controls translation (axes 0 and 1)
            if (Math.abs(gamepad.axes[0]) > axisThreshold) {
                inv = translate4(inv, moveSpeed * gamepad.axes[0], 0, 0);
                carousel = false;
            }
            if (Math.abs(gamepad.axes[1]) > axisThreshold) {
                inv = translate4(inv, 0, 0, -moveSpeed * gamepad.axes[1]);
                carousel = false;
            }
            if(gamepad.buttons[12].pressed || gamepad.buttons[13].pressed){
                inv = translate4(inv, 0, -moveSpeed*(gamepad.buttons[12].pressed - gamepad.buttons[13].pressed), 0);
                carousel = false;
            }

            if(gamepad.buttons[14].pressed || gamepad.buttons[15].pressed){
                inv = translate4(inv, -moveSpeed*(gamepad.buttons[14].pressed - gamepad.buttons[15].pressed), 0, 0);
                carousel = false;
            }

            // Assuming the right stick controls rotation (axes 2 and 3)
            if (Math.abs(gamepad.axes[2]) > axisThreshold) {
                inv = rotate4(inv, rotateSpeed * gamepad.axes[2], 0, 1, 0);
                carousel = false;
            }
            if (Math.abs(gamepad.axes[3]) > axisThreshold) {
                inv = rotate4(inv, -rotateSpeed * gamepad.axes[3], 1, 0, 0);
                carousel = false;
            }

            let tiltAxis = gamepad.buttons[6].value - gamepad.buttons[7].value;
            if (Math.abs(tiltAxis) > axisThreshold) {
                inv = rotate4(inv, rotateSpeed * tiltAxis, 0, 0, 1);
                carousel = false;
            }
            if (gamepad.buttons[4].pressed && !leftGamepadTrigger) {
                camera = cameras[(cameras.indexOf(camera)+1)%cameras.length]
                inv = invert4(getViewMatrix(camera));
                carousel = false;
            }
            if (gamepad.buttons[5].pressed && !rightGamepadTrigger) {
                camera = cameras[(cameras.indexOf(camera)+cameras.length-1)%cameras.length]
                inv = invert4(getViewMatrix(camera));
                carousel = false;
            }
            leftGamepadTrigger = gamepad.buttons[4].pressed;
            rightGamepadTrigger = gamepad.buttons[5].pressed;
            if (gamepad.buttons[0].pressed) {
                isJumping = true;
                carousel = false;
            }
            if(gamepad.buttons[3].pressed){
                carousel = true;
            }
        }

        if (
            ["KeyJ", "KeyK", "KeyL", "KeyI"].some((k) => activeKeys.includes(k))
        ) {
            let d = 4;
            inv = translate4(inv, 0, 0, d);
            inv = rotate4(
                inv,
                activeKeys.includes("KeyJ")
                    ? -0.05
                    : activeKeys.includes("KeyL")
                    ? 0.05
                    : 0,
                0,
                1,
                0,
            );
            inv = rotate4(
                inv,
                activeKeys.includes("KeyI")
                    ? 0.05
                    : activeKeys.includes("KeyK")
                    ? -0.05
                    : 0,
                1,
                0,
                0,
            );
            inv = translate4(inv, 0, 0, -d);
        }

        viewMatrix = invert4(inv);

        if (carousel) {
            let inv = invert4(defaultViewMatrix);

            const t = Math.sin((Date.now() - start) / 5000);
            inv = translate4(inv, 2.5 * t, 0, 6 * (1 - Math.cos(t)));
            inv = rotate4(inv, -0.6 * t, 0, 1, 0);

            viewMatrix = invert4(inv);
        }

        if (isJumping) {
            jumpDelta = Math.min(1, jumpDelta + 0.05);
        } else {
            jumpDelta = Math.max(0, jumpDelta - 0.05);
        }

        let inv2 = invert4(viewMatrix);
        inv2 = translate4(inv2, 0, -jumpDelta, 0);
        inv2 = rotate4(inv2, -0.1 * jumpDelta, 1, 0, 0);
        let actualViewMatrix = invert4(inv2);
        const viewProj = multiply4(projectionMatrix, actualViewMatrix);
       
        worker.postMessage({ view: viewProj });
        list_worker.onmessage = (e) => {
        
            if (e.data.block === 1) {  // or use e.data.block === '1' if it's a string
                blocker = true;
            } else if (e.data.block === 2) {
                blocker = false;
            }
        };
    

        if(!blocker){
            list_worker.postMessage({
                viewMatrix:viewMatrix,
                proj: viewProj
            })
        }
        const currentFps = 1000 / (now - lastFrame) || 0;
        avgFps = avgFps * 0.9 + currentFps * 0.1;
        if (vertexCount > 0) {
            document.getElementById("spinner").style.display = "none";
            gl.uniformMatrix4fv(u_view, false, actualViewMatrix);
            gl.clear(gl.COLOR_BUFFER_BIT);
            //console.log("vertex count", vertexCount)
            gl.drawArraysInstanced(gl.TRIANGLE_FAN, 0, 4, vertexCount);
        } else {
            gl.clear(gl.COLOR_BUFFER_BIT);
            document.getElementById("spinner").style.display = "";
            start = Date.now() + 2000;
        }
        
        fps.innerText = Math.round(avgFps) + " fps";
        if (isNaN(currentCameraIndex)){
            camid.innerText = "";
        }
        d_length.innerText = downloaded_voxels.length;
/*
        
        if(camera.is_key_frame){
            saveCanvasAsPNG(canvas, scene_name+'_nosp_200_' + camera.img_name)
        }
        */
        render_frame++;
        lastFrame = now;
        requestAnimationFrame(frame);
    };
    
    frame();

    let received_voxels;
    list_worker.onmessage = (e) =>{
        if(e.data.required_voxels){
            received_voxels = e.data.required_voxels;  
            if(!all_done){
                download_worker.postMessage({
                    list:received_voxels
                })
            }
            
            
        }
        
    }

    const selectFile = (file) => {
        const fr = new FileReader();
        if (/\.json$/i.test(file.name)) {
            fr.onload = () => {
                cameras = JSON.parse(fr.result);
                viewMatrix = getViewMatrix(cameras[0]);
                projectionMatrix = getProjectionMatrix(
                    camera.fx / downsample,
                    camera.fy / downsample,
                    canvas.width,
                    canvas.height,
                );
                gl.uniformMatrix4fv(u_projection, false, projectionMatrix);

                console.log("Loaded Cameras");
            };
            fr.readAsText(file);
        } else {
            stopLoading = true;
            fr.onload = () => {
                splatData = new Uint8Array(fr.result);
                console.log("Loaded", Math.floor(splatData.length / rowLength));

                if (
                    splatData[0] == 112 &&
                    splatData[1] == 108 &&
                    splatData[2] == 121 &&
                    splatData[3] == 10
                ) {
                    // ply file magic header means it should be handled differently
                    worker.postMessage({ ply: splatData.buffer });
                } else {
                    worker.postMessage({
                        buffer: splatData.buffer,
                        vertexCount: Math.floor(splatData.length / rowLength),
                    });
                }
            };
            fr.readAsArrayBuffer(file);
        }
    };

    window.addEventListener("hashchange", (e) => {
        try {
            viewMatrix = JSON.parse(decodeURIComponent(location.hash.slice(1)));
            carousel = false;
        } catch (err) {}
    });

    const preventDefault = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };
    document.addEventListener("dragenter", preventDefault);
    document.addEventListener("dragover", preventDefault);
    document.addEventListener("dragleave", preventDefault);
    document.addEventListener("drop", (e) => {
        e.preventDefault();
        e.stopPropagation();
        selectFile(e.dataTransfer.files[0]);
    });
    let bytesRead = 0;
    
    let stopLoading = false;
    

    download_worker.onmessage = (e) =>{
        if(e.data.value){
            let breakpoint = download_maneger[e.data.voxel]['breakpoint']
            if( breakpoint % rowLength !=0 & breakpoint!= 0){
                let miss_bytes = rowLength - (breakpoint % rowLength);
                splatData.set(e.data.value.slice(0,miss_bytes),breakpoint);
                splatData.set(e.data.value.slice(miss_bytes),bytesRead);             
                if((e.data.value.length - miss_bytes)%rowLength == 0){
                    download_maneger[e.data.voxel]['breakpoint'] = 0
                    bytesRead += e.data.value.length - miss_bytes
                }else{
                    download_maneger[e.data.voxel]['breakpoint'] = bytesRead + e.data.value.length - miss_bytes;
                    let received_bytes = (Math.floor((e.data.value.length - miss_bytes)/rowLength) + 1) * rowLength;
                    bytesRead += received_bytes;
                }

            }else{
                splatData.set(e.data.value, bytesRead);
                if(e.data.value.length%rowLength == 0){
                    bytesRead += e.data.value.length
                }else{
                    download_maneger[e.data.voxel]['breakpoint'] = bytesRead + e.data.value.length
                    let received_bytes = (Math.floor(e.data.value.length/rowLength) + 1) * rowLength;
                    bytesRead += received_bytes;
                }
                
            }
            if (vertexCount > lastVertexCount) {
                worker.postMessage({
                    buffer: splatData.buffer,
                    vertexCount: Math.floor(bytesRead / rowLength),
                });
                lastVertexCount = vertexCount;
            }
            
        }
        if(e.data.done){
            all_done = true;
        }
    }
    
    
}

main().catch((err) => {
    document.getElementById("spinner").style.display = "none";
    document.getElementById("message").innerText = err.toString();
});
